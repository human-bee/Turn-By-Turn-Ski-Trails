# File Tree - Generated on 2025-01-11 16:34:58

├── LICENSE
├── Package.swift
├── README.md
├── combined_files.txt
├── envmirror.md
├── project.yml
├── App
│   └── SkiTrails
│       ├── Info.plist
│       ├── SkiTrailsApp.swift
│       ├── App
│       ├── Bundle.docc
│       │   ├── Configuration.plist
│       │   └── Info.plist
│       ├── Extensions
│       │   └── SkiDifficulty+Color.swift
│       ├── Images.xcassets
│       │   ├── Contents.json
│       │   └── AppIcon.appiconset
│       │       └── Contents.json
│       ├── Models
│       │   ├── AppState.swift
│       │   ├── HeavenlyData.swift
│       │   ├── Status.swift
│       │   └── TrailDifficulty.swift
│       ├── Resources
│       ├── Services
│       │   ├── APIClient.swift
│       │   ├── ErrorHandler.swift
│       │   ├── LocationManager.swift
│       │   └── ResortDataService.swift
│       ├── Utils
│       │   ├── EnvConfig.swift
│       │   └── MapConfig.swift
│       ├── ViewModels
│       │   ├── ContentViewModel.swift
│       │   ├── MapViewModel.swift
│       │   ├── NavigationViewModel.swift
│       │   └── ResortViewModel.swift
│       └── Views
│           ├── ARResortView.swift
│           ├── ActiveNavigationView.swift
│           ├── ContentView.swift
│           ├── ErrorAlertView.swift
│           ├── MapSelectionView.swift
│           ├── MapView.swift
│           ├── MapboxMapView.swift
│           ├── NavigationSetupView.swift
│           ├── RouteDetailView.swift
│           └── RouteOverlayView.swift
├── SkiTrails.xcodeproj
│   ├── project.pbxproj
│   ├── project.xcworkspace
│   │   ├── contents.xcworkspacedata
│   │   ├── xcshareddata
│   │   │   └── swiftpm
│   │   │       ├── Package.resolved
│   │   │       └── configuration
│   │   └── xcuserdata
│   │       └── bsteinher.xcuserdatad
│   │           └── UserInterfaceState.xcuserstate
│   ├── xcshareddata
│   └── xcuserdata
│       └── bsteinher.xcuserdatad
│           └── xcschemes
│               └── xcschememanagement.plist
├── Sources
│   ├── SkiTrails
│   │   ├── ContentView.swift
│   │   ├── SkiTrailsApp.swift
│   │   └── Images.xcassets
│   │       ├── Contents.json
│   │       └── AppIcon.appiconset
│   │           └── Contents.json
│   └── SkiTrailsCore
│       ├── SkiTrailsCore.swift
│       ├── Configuration
│       │   ├── Configuration.swift
│       │   ├── CoreConfig.swift
│       │   └── MapConfig.swift
│       ├── Models
│       │   ├── AppState.swift
│       │   ├── HeavenlyData.swift
│       │   ├── MapFeature.swift
│       │   ├── Resort.swift
│       │   └── Status.swift
│       ├── Routing
│       │   ├── RoutingEngine.swift
│       │   └── RoutingTypes.swift
│       └── ViewModels
│           └── MapViewModel.swift
└── Tests
    └── SkiTrailsTests
        └── SkiTrailsTests.swift

# Combined Files Content


### File: LICENSE
MIT License

Copyright (c) 2024 Turn-By-Turn Ski Trails

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE. 

### File: Package.swift
// swift-tools-version:5.9
import PackageDescription

let package = Package(
    name: "SkiTrails",
    platforms: [
        .iOS(.v15)
    ],
    products: [
        .library(
            name: "SkiTrailsCore",
            targets: ["SkiTrailsCore"]
        )
    ],
    dependencies: [
        .package(url: "https://github.com/mapbox/mapbox-maps-ios.git", from: "10.16.0"),
        .package(url: "https://github.com/getsentry/sentry-cocoa.git", from: "8.17.1")
    ],
    targets: [
        .target(
            name: "SkiTrailsCore",
            dependencies: [
                .product(name: "MapboxMaps", package: "mapbox-maps-ios"),
                .product(name: "Sentry", package: "sentry-cocoa")
            ],
            path: "Sources/SkiTrailsCore"
        ),
        .testTarget(
            name: "SkiTrailsCoreTests",
            dependencies: ["SkiTrailsCore"]
        )
    ]
) 

### File: README.md
# Turn-By-Turn Ski Trails

A 3D ski resort mapping application built with SwiftUI that provides interactive trail maps, turn-by-turn navigation, and real-time resort information.

## Features

- Interactive 3D map of ski resorts with lifts and runs
- Turn-by-turn navigation between points
- Filtering for runs by difficulty level
- Real-time lift and run status updates
- Weather and snow condition information

## Requirements

- iOS 15.0+
- Xcode 13.0+
- Swift 5.5+

## Installation

1. Clone the repository
2. Copy `.env.example` to `.env` and fill in your API keys
3. Open `SkiTrails.xcodeproj` in Xcode
4. Build and run

## APIs Used

- Mapbox for 3D terrain visualization
- Weather Unlocked for snow and weather data
- Liftie API for real-time lift status
- Custom routing engine for navigation

## Architecture

The app follows a clean architecture pattern with:

- SwiftUI views for the UI layer
- MVVM pattern for presentation logic
- Domain layer for business logic
- Data layer for API integration

## License

This project is licensed under the MIT License - see the LICENSE file for details. 

### File: envmirror.md
# Environment configuration for the Ski Resort Mapping App

# 3D Map Rendering API
MAPBOX_ACCESS_TOKEN=your_mapbox_token_here

# Real-Time Weather and Snow Data APIs
WEATHER_UNLOCKED_API_KEY=your_weather_unlocked_api_key_here
WEATHER_UNLOCKED_APP_ID=your_weather_unlocked_app_id_here

SKI_API_KEY=your_ski_api_key_here

# Liftie API Configuration
LIFTIE_API_BASE_URL=https://liftie.info/api/resort
LIFTIE_REFRESH_INTERVAL=65000
LIFTIE_RESORT_LIST=alpine,palisades

# Ski Resorts Information API
Ski_Resorts_Information_API-KEY=your_ski_resorts_information_api_key_here

# Navigation and Routing
NAVIGATION_API_KEY=your_navigation_api_key_here
GRAPHQL_ENDPOINT=your_graphql_endpoint_here
GRAPHQL_AUTH_TOKEN=your_graphql_auth_token_here

# Backend Server Configuration
API_BASE_URL=your_api_base_url_here
API_AUTH_TOKEN=your_api_auth_token_here

# Real-Time Updates
REALTIME_API_URL=your_realtime_api_url_here
REALTIME_API_KEY=your_realtime_api_key_here

# App Configuration
APP_ENV=development
DEBUG_MODE=true

# Firebase Configuration
FIREBASE_API_KEY=your_firebase_api_key_here
FIREBASE_PROJECT_ID=your_firebase_project_id_here
FIREBASE_MESSAGING_SENDER_ID=your_firebase_messaging_sender_id_here
FIREBASE_APP_ID=your_firebase_app_id_here

# Analytics and Logging
GOOGLE_ANALYTICS_KEY=your_google_analytics_key_here

SENTRY_DSN=your_sentry_dsn_here
# Custom Configuration
CUSTOM_3D_MODEL_URL=your_custom_3d_model_url_here 

### File: project.yml
name: SkiTrails
options:
  bundleIdPrefix: com.skitrails
  deploymentTarget:
    iOS: 17.0
packages:
  SkiTrailsCore:
    path: .
targets:
  SkiTrails:
    type: application
    platform: iOS
    sources: 
      - path: App/SkiTrails
        excludes:
          - "Resources/Info.plist"
    dependencies:
      - package: SkiTrailsCore
    settings:
      base:
        INFOPLIST_FILE: App/SkiTrails/Info.plist
        PRODUCT_BUNDLE_IDENTIFIER: com.skitrails.app
        DEVELOPMENT_TEAM: ""  # Add your team ID here if you have one
    info:
      path: App/SkiTrails/Info.plist
      properties:
        CFBundleName: SkiTrails
        CFBundleDisplayName: Ski Trails
        CFBundlePackageType: APPL
        UILaunchScreen: {}
        UISupportedInterfaceOrientations:
          - UIInterfaceOrientationPortrait
          - UIInterfaceOrientationLandscapeLeft
          - UIInterfaceOrientationLandscapeRight
        UIRequiredDeviceCapabilities:
          - armv7

### File: SkiTrails.xcodeproj/project.pbxproj
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 54;
	objects = {

/* Begin PBXBuildFile section */
		0B5014D9329D06867A9FD80D /* AppState.swift in Sources */ = {isa = PBXBuildFile; fileRef = CE46DEFE5ADAF894ACF58737 /* AppState.swift */; };
		107B3B570B3A705BAABAEB92 /* Status.swift in Sources */ = {isa = PBXBuildFile; fileRef = 053C4A8BC3F23F6BA2C7DAF2 /* Status.swift */; };
		26B937D0929A52555D69F171 /* RouteOverlayView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 4018E0D9BC219FA053EBD891 /* RouteOverlayView.swift */; };
		2A61397B2822CAEFEBCD0450 /* EnvConfig.swift in Sources */ = {isa = PBXBuildFile; fileRef = 5B8C1E2E0AE5613BD252AA4F /* EnvConfig.swift */; };
		32D125DB9AB7EE19D72B048B /* MapConfig.swift in Sources */ = {isa = PBXBuildFile; fileRef = 7DAD6C4F59D0C461E3DCF2B3 /* MapConfig.swift */; };
		5140E7AA6FF254127FB3DC1D /* ErrorHandler.swift in Sources */ = {isa = PBXBuildFile; fileRef = 324BFD5B8EE7F7CFDF800302 /* ErrorHandler.swift */; };
		55CBA987729ABAC2E18DD503 /* ResortDataService.swift in Sources */ = {isa = PBXBuildFile; fileRef = 46E103FECD896A70BFD44E28 /* ResortDataService.swift */; };
		662C570CD69327DB1C6A3D33 /* MapboxMapView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 9FB988E56C7140BC5FA7DCF1 /* MapboxMapView.swift */; };
		6769D0086CA909B8101C1340 /* ErrorAlertView.swift in Sources */ = {isa = PBXBuildFile; fileRef = BE6147B0EB4588ECFD61FF68 /* ErrorAlertView.swift */; };
		7D8414427949D0BEA5B0300D /* Images.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = FE70309CC8B8F58EE313E5BB /* Images.xcassets */; };
		805A093423E612E654BD42C5 /* SkiDifficulty+Color.swift in Sources */ = {isa = PBXBuildFile; fileRef = 5B2CE8D8E4CEEB02C2863374 /* SkiDifficulty+Color.swift */; };
		809F7DFFE2F8A635F9BC2D67 /* TrailDifficulty.swift in Sources */ = {isa = PBXBuildFile; fileRef = 5DB02AF5CAE496D19851BFA9 /* TrailDifficulty.swift */; };
		882858AC29BBE650F17327DB /* ResortViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2EC4C62A02070B61139FD8F9 /* ResortViewModel.swift */; };
		A73348954D8F0C3B73FB6A7A /* LocationManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = DF0FFF047DDFCD14EBC10226 /* LocationManager.swift */; };
		A75B222A900D27E627CABCA9 /* ARResortView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 203DBF0F671114F5A5DA62E8 /* ARResortView.swift */; };
		A875F05EECAF91015197B632 /* MapView.swift in Sources */ = {isa = PBXBuildFile; fileRef = EF3EB4DCAEC0536C096B2481 /* MapView.swift */; };
		B2A996E5E14DC4789B3928E7 /* HeavenlyData.swift in Sources */ = {isa = PBXBuildFile; fileRef = 08CE2DCF4E9E957DAAC852A8 /* HeavenlyData.swift */; };
		B88497FAE5A09A4099CEBB7B /* ActiveNavigationView.swift in Sources */ = {isa = PBXBuildFile; fileRef = E3877CA5314794946FFE7A8A /* ActiveNavigationView.swift */; };
		BAE8102B28781C71D8678CF8 /* MapViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = A4702513E31F15384502A9E1 /* MapViewModel.swift */; };
		C81BC7A4A579B6D930E1D03F /* Bundle.docc in Sources */ = {isa = PBXBuildFile; fileRef = 82A1BE5D30A95AF4AFE86D12 /* Bundle.docc */; };
		E20AA8CA3DEBB1A14B78A9CF /* SkiTrailsCore in Frameworks */ = {isa = PBXBuildFile; productRef = 9B17550135285C86A4ACF238 /* SkiTrailsCore */; };
		E2DCC7225F0EB7EAF5CE040F /* APIClient.swift in Sources */ = {isa = PBXBuildFile; fileRef = EB5093C840EDEEB89867410E /* APIClient.swift */; };
		E45D015DFD4104FFF94A1D95 /* SkiTrailsApp.swift in Sources */ = {isa = PBXBuildFile; fileRef = 992CD0412B09B24970EC0C25 /* SkiTrailsApp.swift */; };
		E8222E68FCAF85CCDACD0BD6 /* NavigationViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 272EBEB2D63D2B0862FBF598 /* NavigationViewModel.swift */; };
		F5E3C158EC4D906981D043B6 /* MapSelectionView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 1612AE442E97D041364E6110 /* MapSelectionView.swift */; };
		F74BD58FE1A5D0D38346E923 /* ContentViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2F004D3EA57B2C8DC90E4A01 /* ContentViewModel.swift */; };
		FD516AF8B02607E4B3D128D6 /* RouteDetailView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 01BA6E1021CCF40744665C70 /* RouteDetailView.swift */; };
		FDFAEF13CDE5C4A7609133EE /* ContentView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 09ED9FEAFBD6E8882EE29F8C /* ContentView.swift */; };
/* End PBXBuildFile section */

/* Begin PBXFileReference section */
		01BA6E1021CCF40744665C70 /* RouteDetailView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = RouteDetailView.swift; sourceTree = "<group>"; };
		053C4A8BC3F23F6BA2C7DAF2 /* Status.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = Status.swift; sourceTree = "<group>"; };
		08CE2DCF4E9E957DAAC852A8 /* HeavenlyData.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = HeavenlyData.swift; sourceTree = "<group>"; };
		09ED9FEAFBD6E8882EE29F8C /* ContentView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ContentView.swift; sourceTree = "<group>"; };
		1612AE442E97D041364E6110 /* MapSelectionView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MapSelectionView.swift; sourceTree = "<group>"; };
		203DBF0F671114F5A5DA62E8 /* ARResortView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ARResortView.swift; sourceTree = "<group>"; };
		272EBEB2D63D2B0862FBF598 /* NavigationViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = NavigationViewModel.swift; sourceTree = "<group>"; };
		2EC4C62A02070B61139FD8F9 /* ResortViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ResortViewModel.swift; sourceTree = "<group>"; };
		2F004D3EA57B2C8DC90E4A01 /* ContentViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ContentViewModel.swift; sourceTree = "<group>"; };
		324BFD5B8EE7F7CFDF800302 /* ErrorHandler.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ErrorHandler.swift; sourceTree = "<group>"; };
		4018E0D9BC219FA053EBD891 /* RouteOverlayView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = RouteOverlayView.swift; sourceTree = "<group>"; };
		46E103FECD896A70BFD44E28 /* ResortDataService.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ResortDataService.swift; sourceTree = "<group>"; };
		5B2CE8D8E4CEEB02C2863374 /* SkiDifficulty+Color.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "SkiDifficulty+Color.swift"; sourceTree = "<group>"; };
		5B8C1E2E0AE5613BD252AA4F /* EnvConfig.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = EnvConfig.swift; sourceTree = "<group>"; };
		5DB02AF5CAE496D19851BFA9 /* TrailDifficulty.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = TrailDifficulty.swift; sourceTree = "<group>"; };
		6E6CBA856E8A79DBEB326CCE /* SkiTrails.app */ = {isa = PBXFileReference; includeInIndex = 0; lastKnownFileType = wrapper.application; path = SkiTrails.app; sourceTree = BUILT_PRODUCTS_DIR; };
		7DAD6C4F59D0C461E3DCF2B3 /* MapConfig.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MapConfig.swift; sourceTree = "<group>"; };
		82A1BE5D30A95AF4AFE86D12 /* Bundle.docc */ = {isa = PBXFileReference; lastKnownFileType = folder.documentationcatalog; path = Bundle.docc; sourceTree = "<group>"; };
		95C0894FB5338108B4AFC4D3 /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist; path = Info.plist; sourceTree = "<group>"; };
		992CD0412B09B24970EC0C25 /* SkiTrailsApp.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SkiTrailsApp.swift; sourceTree = "<group>"; };
		9FB988E56C7140BC5FA7DCF1 /* MapboxMapView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MapboxMapView.swift; sourceTree = "<group>"; };
		A4702513E31F15384502A9E1 /* MapViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MapViewModel.swift; sourceTree = "<group>"; };
		A597BF9A7BF5DBD0BD076FBB /* Turn-By-Turn Ski Trails */ = {isa = PBXFileReference; lastKnownFileType = folder; name = "Turn-By-Turn Ski Trails"; path = .; sourceTree = SOURCE_ROOT; };
		BE6147B0EB4588ECFD61FF68 /* ErrorAlertView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ErrorAlertView.swift; sourceTree = "<group>"; };
		CE46DEFE5ADAF894ACF58737 /* AppState.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AppState.swift; sourceTree = "<group>"; };
		DF0FFF047DDFCD14EBC10226 /* LocationManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = LocationManager.swift; sourceTree = "<group>"; };
		E3877CA5314794946FFE7A8A /* ActiveNavigationView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ActiveNavigationView.swift; sourceTree = "<group>"; };
		EB5093C840EDEEB89867410E /* APIClient.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = APIClient.swift; sourceTree = "<group>"; };
		EF3EB4DCAEC0536C096B2481 /* MapView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MapView.swift; sourceTree = "<group>"; };
		FE70309CC8B8F58EE313E5BB /* Images.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; path = Images.xcassets; sourceTree = "<group>"; };
/* End PBXFileReference section */

/* Begin PBXFrameworksBuildPhase section */
		03E5D09EE30F8D8AC10ABC36 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				E20AA8CA3DEBB1A14B78A9CF /* SkiTrailsCore in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		0104433A3856A1887CCBD7A8 /* ViewModels */ = {
			isa = PBXGroup;
			children = (
				2F004D3EA57B2C8DC90E4A01 /* ContentViewModel.swift */,
				A4702513E31F15384502A9E1 /* MapViewModel.swift */,
				272EBEB2D63D2B0862FBF598 /* NavigationViewModel.swift */,
				2EC4C62A02070B61139FD8F9 /* ResortViewModel.swift */,
			);
			path = ViewModels;
			sourceTree = "<group>";
		};
		15482248925DF424DCBFAF39 /* Services */ = {
			isa = PBXGroup;
			children = (
				EB5093C840EDEEB89867410E /* APIClient.swift */,
				324BFD5B8EE7F7CFDF800302 /* ErrorHandler.swift */,
				DF0FFF047DDFCD14EBC10226 /* LocationManager.swift */,
				46E103FECD896A70BFD44E28 /* ResortDataService.swift */,
			);
			path = Services;
			sourceTree = "<group>";
		};
		1ABE3BB06F6DCB1C39113EE1 /* Products */ = {
			isa = PBXGroup;
			children = (
				6E6CBA856E8A79DBEB326CCE /* SkiTrails.app */,
			);
			name = Products;
			sourceTree = "<group>";
		};
		2A2988683567B9359FC4C917 /* Models */ = {
			isa = PBXGroup;
			children = (
				CE46DEFE5ADAF894ACF58737 /* AppState.swift */,
				08CE2DCF4E9E957DAAC852A8 /* HeavenlyData.swift */,
				053C4A8BC3F23F6BA2C7DAF2 /* Status.swift */,
				5DB02AF5CAE496D19851BFA9 /* TrailDifficulty.swift */,
			);
			path = Models;
			sourceTree = "<group>";
		};
		5BCF01F2AF57567CDED76DE8 /* Packages */ = {
			isa = PBXGroup;
			children = (
				A597BF9A7BF5DBD0BD076FBB /* Turn-By-Turn Ski Trails */,
			);
			name = Packages;
			sourceTree = "<group>";
		};
		76643AF32E0967ECFB90DC00 /* Views */ = {
			isa = PBXGroup;
			children = (
				E3877CA5314794946FFE7A8A /* ActiveNavigationView.swift */,
				203DBF0F671114F5A5DA62E8 /* ARResortView.swift */,
				09ED9FEAFBD6E8882EE29F8C /* ContentView.swift */,
				BE6147B0EB4588ECFD61FF68 /* ErrorAlertView.swift */,
				9FB988E56C7140BC5FA7DCF1 /* MapboxMapView.swift */,
				1612AE442E97D041364E6110 /* MapSelectionView.swift */,
				EF3EB4DCAEC0536C096B2481 /* MapView.swift */,
				01BA6E1021CCF40744665C70 /* RouteDetailView.swift */,
				4018E0D9BC219FA053EBD891 /* RouteOverlayView.swift */,
			);
			path = Views;
			sourceTree = "<group>";
		};
		CE101271C4E3731C6FB65B56 /* SkiTrails */ = {
			isa = PBXGroup;
			children = (
				82A1BE5D30A95AF4AFE86D12 /* Bundle.docc */,
				FE70309CC8B8F58EE313E5BB /* Images.xcassets */,
				95C0894FB5338108B4AFC4D3 /* Info.plist */,
				992CD0412B09B24970EC0C25 /* SkiTrailsApp.swift */,
				D1A06D7581FC0979DC8D342A /* Extensions */,
				2A2988683567B9359FC4C917 /* Models */,
				15482248925DF424DCBFAF39 /* Services */,
				D414916A0E121509EED16293 /* Utils */,
				0104433A3856A1887CCBD7A8 /* ViewModels */,
				76643AF32E0967ECFB90DC00 /* Views */,
			);
			name = SkiTrails;
			path = App/SkiTrails;
			sourceTree = "<group>";
		};
		D1A06D7581FC0979DC8D342A /* Extensions */ = {
			isa = PBXGroup;
			children = (
				5B2CE8D8E4CEEB02C2863374 /* SkiDifficulty+Color.swift */,
			);
			path = Extensions;
			sourceTree = "<group>";
		};
		D414916A0E121509EED16293 /* Utils */ = {
			isa = PBXGroup;
			children = (
				5B8C1E2E0AE5613BD252AA4F /* EnvConfig.swift */,
				7DAD6C4F59D0C461E3DCF2B3 /* MapConfig.swift */,
			);
			path = Utils;
			sourceTree = "<group>";
		};
		E7600A4B8E6838A911842EC4 = {
			isa = PBXGroup;
			children = (
				5BCF01F2AF57567CDED76DE8 /* Packages */,
				CE101271C4E3731C6FB65B56 /* SkiTrails */,
				1ABE3BB06F6DCB1C39113EE1 /* Products */,
			);
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		96518D38BCB168FF546BEB0A /* SkiTrails */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 917C2054A5C03904F4321532 /* Build configuration list for PBXNativeTarget "SkiTrails" */;
			buildPhases = (
				733F5A90F8B155439D1BA718 /* Sources */,
				924224D7C0E761A7AC4E3345 /* Resources */,
				03E5D09EE30F8D8AC10ABC36 /* Frameworks */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = SkiTrails;
			packageProductDependencies = (
				9B17550135285C86A4ACF238 /* SkiTrailsCore */,
			);
			productName = SkiTrails;
			productReference = 6E6CBA856E8A79DBEB326CCE /* SkiTrails.app */;
			productType = "com.apple.product-type.application";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		4D4F3220CB8E0311838C7942 /* Project object */ = {
			isa = PBXProject;
			attributes = {
				BuildIndependentTargetsInParallel = YES;
				LastUpgradeCheck = 1430;
				TargetAttributes = {
					96518D38BCB168FF546BEB0A = {
						DevelopmentTeam = "";
					};
				};
			};
			buildConfigurationList = 56F5DD0F0E42882467027528 /* Build configuration list for PBXProject "SkiTrails" */;
			compatibilityVersion = "Xcode 14.0";
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				Base,
				en,
			);
			mainGroup = E7600A4B8E6838A911842EC4;
			packageReferences = (
				BD1250636415268544056933 /* XCLocalSwiftPackageReference "." */,
			);
			projectDirPath = "";
			projectRoot = "";
			targets = (
				96518D38BCB168FF546BEB0A /* SkiTrails */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		924224D7C0E761A7AC4E3345 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				7D8414427949D0BEA5B0300D /* Images.xcassets in Resources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		733F5A90F8B155439D1BA718 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				E2DCC7225F0EB7EAF5CE040F /* APIClient.swift in Sources */,
				A75B222A900D27E627CABCA9 /* ARResortView.swift in Sources */,
				B88497FAE5A09A4099CEBB7B /* ActiveNavigationView.swift in Sources */,
				0B5014D9329D06867A9FD80D /* AppState.swift in Sources */,
				C81BC7A4A579B6D930E1D03F /* Bundle.docc in Sources */,
				FDFAEF13CDE5C4A7609133EE /* ContentView.swift in Sources */,
				F74BD58FE1A5D0D38346E923 /* ContentViewModel.swift in Sources */,
				2A61397B2822CAEFEBCD0450 /* EnvConfig.swift in Sources */,
				6769D0086CA909B8101C1340 /* ErrorAlertView.swift in Sources */,
				5140E7AA6FF254127FB3DC1D /* ErrorHandler.swift in Sources */,
				B2A996E5E14DC4789B3928E7 /* HeavenlyData.swift in Sources */,
				A73348954D8F0C3B73FB6A7A /* LocationManager.swift in Sources */,
				32D125DB9AB7EE19D72B048B /* MapConfig.swift in Sources */,
				F5E3C158EC4D906981D043B6 /* MapSelectionView.swift in Sources */,
				A875F05EECAF91015197B632 /* MapView.swift in Sources */,
				BAE8102B28781C71D8678CF8 /* MapViewModel.swift in Sources */,
				662C570CD69327DB1C6A3D33 /* MapboxMapView.swift in Sources */,
				E8222E68FCAF85CCDACD0BD6 /* NavigationViewModel.swift in Sources */,
				55CBA987729ABAC2E18DD503 /* ResortDataService.swift in Sources */,
				882858AC29BBE650F17327DB /* ResortViewModel.swift in Sources */,
				FD516AF8B02607E4B3D128D6 /* RouteDetailView.swift in Sources */,
				26B937D0929A52555D69F171 /* RouteOverlayView.swift in Sources */,
				805A093423E612E654BD42C5 /* SkiDifficulty+Color.swift in Sources */,
				E45D015DFD4104FFF94A1D95 /* SkiTrailsApp.swift in Sources */,
				107B3B570B3A705BAABAEB92 /* Status.swift in Sources */,
				809F7DFFE2F8A635F9BC2D67 /* TrailDifficulty.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin XCBuildConfiguration section */
		59CE62758876D9875EDA249A /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CODE_SIGN_IDENTITY = "iPhone Developer";
				DEVELOPMENT_TEAM = "";
				INFOPLIST_FILE = App/SkiTrails/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.skitrails.app;
				SDKROOT = iphoneos;
				TARGETED_DEVICE_FAMILY = "1,2";
			};
			name = Release;
		};
		5D49474E482F4E46E47F91AD /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++14";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = dwarf;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				GCC_C_LANGUAGE_STANDARD = gnu11;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"$(inherited)",
					"DEBUG=1",
				);
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 17.0;
				MTL_ENABLE_DEBUG_INFO = INCLUDE_SOURCE;
				MTL_FAST_MATH = YES;
				ONLY_ACTIVE_ARCH = YES;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SDKROOT = iphoneos;
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = DEBUG;
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				SWIFT_VERSION = 5.0;
			};
			name = Debug;
		};
		AADCA4D5824BA16A0DF0BE8D /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++14";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				GCC_C_LANGUAGE_STANDARD = gnu11;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 17.0;
				MTL_ENABLE_DEBUG_INFO = NO;
				MTL_FAST_MATH = YES;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SDKROOT = iphoneos;
				SWIFT_COMPILATION_MODE = wholemodule;
				SWIFT_OPTIMIZATION_LEVEL = "-O";
				SWIFT_VERSION = 5.0;
			};
			name = Release;
		};
		D4DF2BA5766F3688F2AF0D32 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CODE_SIGN_IDENTITY = "iPhone Developer";
				DEVELOPMENT_TEAM = "";
				INFOPLIST_FILE = App/SkiTrails/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.skitrails.app;
				SDKROOT = iphoneos;
				TARGETED_DEVICE_FAMILY = "1,2";
			};
			name = Debug;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		56F5DD0F0E42882467027528 /* Build configuration list for PBXProject "SkiTrails" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				5D49474E482F4E46E47F91AD /* Debug */,
				AADCA4D5824BA16A0DF0BE8D /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Debug;
		};
		917C2054A5C03904F4321532 /* Build configuration list for PBXNativeTarget "SkiTrails" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				D4DF2BA5766F3688F2AF0D32 /* Debug */,
				59CE62758876D9875EDA249A /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Debug;
		};
/* End XCConfigurationList section */

/* Begin XCLocalSwiftPackageReference section */
		BD1250636415268544056933 /* XCLocalSwiftPackageReference "." */ = {
			isa = XCLocalSwiftPackageReference;
			relativePath = .;
		};
/* End XCLocalSwiftPackageReference section */

/* Begin XCSwiftPackageProductDependency section */
		9B17550135285C86A4ACF238 /* SkiTrailsCore */ = {
			isa = XCSwiftPackageProductDependency;
			productName = SkiTrailsCore;
		};
/* End XCSwiftPackageProductDependency section */
	};
	rootObject = 4D4F3220CB8E0311838C7942 /* Project object */;
}


### File: SkiTrails.xcodeproj/xcuserdata/bsteinher.xcuserdatad/xcschemes/xcschememanagement.plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>SchemeUserState</key>
	<dict>
		<key>SkiTrails.xcscheme_^#shared#^_</key>
		<dict>
			<key>orderHint</key>
			<integer>0</integer>
		</dict>
	</dict>
</dict>
</plist>


### File: SkiTrails.xcodeproj/project.xcworkspace/contents.xcworkspacedata
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "self:">
   </FileRef>
</Workspace>


### File: SkiTrails.xcodeproj/project.xcworkspace/xcshareddata/swiftpm/Package.resolved
{
  "pins" : [
    {
      "identity" : "mapbox-common-ios",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/mapbox/mapbox-common-ios.git",
      "state" : {
        "revision" : "ce35687685331b1690149637d25ddc47d88146de",
        "version" : "23.11.2"
      }
    },
    {
      "identity" : "mapbox-core-maps-ios",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/mapbox/mapbox-core-maps-ios.git",
      "state" : {
        "revision" : "95bb164a4ca016cb6fce3cdfb13c4902bf8b8c18",
        "version" : "10.19.2"
      }
    },
    {
      "identity" : "mapbox-maps-ios",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/mapbox/mapbox-maps-ios.git",
      "state" : {
        "revision" : "0af0d49fe085923af5dcd00714ec0c6c129a44f3",
        "version" : "10.19.1"
      }
    },
    {
      "identity" : "sentry-cocoa",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/getsentry/sentry-cocoa.git",
      "state" : {
        "revision" : "f45e9c62d7a4d9258ac3cf35a3acf9dbab4481d1",
        "version" : "8.43.0"
      }
    },
    {
      "identity" : "turf-swift",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/mapbox/turf-swift.git",
      "state" : {
        "revision" : "213050191cfcb3d5aa76e1fa90c6ff1e182a42ca",
        "version" : "2.8.0"
      }
    }
  ],
  "version" : 2
}


### File: App/SkiTrails/Info.plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>$(DEVELOPMENT_LANGUAGE)</string>
	<key>CFBundleDisplayName</key>
	<string>Ski Trails</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>SkiTrails</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>1.0</string>
	<key>CFBundleVersion</key>
	<string>1</string>
	<key>UILaunchScreen</key>
	<dict/>
	<key>UIRequiredDeviceCapabilities</key>
	<array>
		<string>armv7</string>
	</array>
	<key>UISupportedInterfaceOrientations</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
</dict>
</plist>


### File: App/SkiTrails/SkiTrailsApp.swift
import SwiftUI
import Sentry
import SkiTrailsCore

@main
struct SkiTrailsApp: App {
    @StateObject private var appState = AppState()
    
    init() {
        do {
            let dsn = try CoreConfig.getDSN()
            SentrySDK.start { options in
                options.dsn = dsn
                options.debug = true
                options.tracesSampleRate = 1.0
                options.enableSwizzling = true
            }
        } catch let error as CoreConfig.Error {
            switch error {
            case .fileNotFound(let path):
                print("Failed to initialize Sentry: .env file not found at \(path)")
            case .invalidFormat:
                print("Failed to initialize Sentry: Invalid .env file format")
            case .missingKey(let key):
                print("Failed to initialize Sentry: Missing key \(key) in .env file")
            }
        } catch {
            print("Failed to initialize Sentry: \(error.localizedDescription)")
        }
    }
    
    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(appState)
        }
    }
} 

### File: App/SkiTrails/Bundle.docc/Configuration.plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>CFBundleIdentifier</key>
    <string>com.skitrails.app</string>
    <key>CFBundleInfoDictionaryVersion</key>
    <string>6.0</string>
    <key>CFBundleName</key>
    <string>SkiTrails</string>
    <key>CFBundlePackageType</key>
    <string>APPL</string>
    <key>CFBundleShortVersionString</key>
    <string>1.0</string>
    <key>CFBundleVersion</key>
    <string>1</string>
    <key>LSRequiresIPhoneOS</key>
    <true/>
    <key>UILaunchStoryboardName</key>
    <string>LaunchScreen</string>
    <key>UIRequiredDeviceCapabilities</key>
    <array>
        <string>armv7</string>
    </array>
    <key>UISupportedInterfaceOrientations</key>
    <array>
        <string>UIInterfaceOrientationPortrait</string>
        <string>UIInterfaceOrientationLandscapeLeft</string>
        <string>UIInterfaceOrientationLandscapeRight</string>
    </array>
</dict>
</plist> 

### File: App/SkiTrails/Bundle.docc/Info.plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>NSLocationWhenInUseUsageDescription</key>
    <string>We need your location to show you where you are on the ski resort map...</string>
    <key>NSLocationAlwaysAndWhenInUseUsageDescription</key>
    <string>We need your location to show you where you are on the ski resort map...</string>
    <key>NSLocationAlwaysUsageDescription</key>
    <string>We need your location to show you where you are on the ski resort map...</string>
    <key>NSCameraUsageDescription</key>
    <string>We need camera access to show ski runs in augmented reality...</string>
    <key>UIBackgroundModes</key>
    <array>
        <string>location</string>
    </array>
    <key>CFBundleURLTypes</key>
    <array>
        <dict>
            <key>CFBundleURLSchemes</key>
            <array>
                <string>skitrails</string>
            </array>
            <key>CFBundleURLName</key>
            <string>com.skitrails.app</string>
        </dict>
    </array>
</dict>
</plist> 

### File: App/SkiTrails/ViewModels/ContentViewModel.swift
import SwiftUI
import CoreLocation

@MainActor
class ContentViewModel: ObservableObject {
    @Published var routeCoordinates: [CLLocationCoordinate2D] = []
    @Published private(set) var isLoading = false
    @Published private(set) var error: Error?
    
    func setLoading(_ loading: Bool) {
        isLoading = loading
    }
    
    func handleError(_ error: Error) {
        self.error = error
    }
    
    func clearRoute() {
        routeCoordinates = []
    }
} 

### File: App/SkiTrails/ViewModels/MapViewModel.swift
import SwiftUI
import CoreLocation
import SkiTrailsCore

class MapViewModel: ObservableObject {
    @Published var selectedFeature: MapFeature?
    
    let defaultCenter = CLLocationCoordinate2D(latitude: 39.6403, longitude: -106.3742) // Vail, CO
    let defaultZoom = 14.0
    let defaultPitch = 45.0
    let defaultBearing = 0.0
} 

### File: App/SkiTrails/ViewModels/NavigationViewModel.swift
import SwiftUI
import SkiTrailsCore
import Combine
import CoreLocation

@MainActor
class NavigationViewModel: ObservableObject {
    @Published private(set) var currentRoute: SkiTrailsCore.Route?
    @Published private(set) var isNavigating = false
    @Published private(set) var isCalculating = false
    @Published private(set) var error: Error?
    
    private let routingEngine: RoutingEngine
    
    init() {
        self.routingEngine = RoutingEngine.shared
    }
    
    func startNavigation(
        from start: CLLocationCoordinate2D,
        to end: CLLocationCoordinate2D,
        difficulty: SkiTrailsCore.SkiDifficulty = .intermediate,
        preferences: RoutePreferences = RoutePreferences(
            avoidCrowds: false,
            preferLessStrenuous: false,
            maxWaitTime: nil
        )
    ) async {
        isCalculating = true
        error = nil
        
        do {
            let route = try await routingEngine.findRoute(
                from: start,
                to: end,
                difficulty: difficulty,
                preferences: preferences
            )
            currentRoute = route
            isNavigating = true
        } catch {
            self.error = error
        }
        
        isCalculating = false
    }
    
    func endNavigation() {
        isNavigating = false
        currentRoute = nil
        error = nil
    }
    
    enum NavigationError: LocalizedError {
        case noRouteFound
        
        var errorDescription: String? {
            switch self {
            case .noRouteFound:
                return "No suitable route found between the selected points"
            }
        }
    }
} 

### File: App/SkiTrails/ViewModels/ResortViewModel.swift
import SwiftUI
import SkiTrailsCore
import Combine

@MainActor
class ResortViewModel: ObservableObject {
    @Published private(set) var selectedResort: Resort?
    @Published private(set) var isLoading = false
    @Published private(set) var error: Error?
    
    private var statusRefreshTask: Task<Void, Never>?
    private let refreshInterval: TimeInterval = 60 // Refresh every minute
    
    init() {
        startStatusRefreshTimer()
    }
    
    deinit {
        statusRefreshTask?.cancel()
    }
    
    func selectResort(_ resort: Resort) {
        selectedResort = resort
    }
    
    private func startStatusRefreshTimer() {
        statusRefreshTask = Task {
            while !Task.isCancelled {
                await refreshResortStatus()
                try? await Task.sleep(nanoseconds: UInt64(refreshInterval * 1_000_000_000))
            }
        }
    }
    
    private func refreshResortStatus() async {
        guard let resort = selectedResort else { return }
        do {
            isLoading = true
            let updatedResort = try await APIClient.shared.fetchResortInfo(id: resort.id.uuidString)
            selectedResort = updatedResort
            isLoading = false
        } catch {
            self.error = error
            isLoading = false
        }
    }
} 

### File: App/SkiTrails/Utils/EnvConfig.swift
import Foundation

/// A utility struct that provides type-safe access to environment variables
enum EnvConfig {
    static let isDebugMode = true
    
    // MARK: - Map Rendering
    static var mapboxAccessToken: String {
        ProcessInfo.processInfo.environment["MAPBOX_ACCESS_TOKEN"] ?? ""
    }
    
    // MARK: - Weather and Snow Data
    static var weatherUnlockedApiKey: String {
        ProcessInfo.processInfo.environment["WEATHER_UNLOCKED_API_KEY"] ?? ""
    }
    
    static var weatherUnlockedAppId: String {
        ProcessInfo.processInfo.environment["WEATHER_UNLOCKED_APP_ID"] ?? ""
    }
    
    static var skiApiKey: String {
        ProcessInfo.processInfo.environment["SKI_API_KEY"] ?? ""
    }
    
    // MARK: - Liftie API
    static var liftieApiBaseUrl: String {
        ProcessInfo.processInfo.environment["LIFTIE_API_BASE_URL"] ?? "https://liftie.info/api/resort"
    }
    
    static var liftieRefreshInterval: TimeInterval {
        Double(ProcessInfo.processInfo.environment["LIFTIE_REFRESH_INTERVAL"] ?? "65000") ?? 65000
    }
    
    static var liftieResortList: [String] {
        let list = ProcessInfo.processInfo.environment["LIFTIE_RESORT_LIST"] ?? ""
        return list.split(separator: ",").map(String.init)
    }
    
    // MARK: - Ski Resorts Information
    static var skiResortsInformationApiKey: String {
        ProcessInfo.processInfo.environment["SKI_RESORTS_INFORMATION_API_KEY"] ?? ""
    }
    
    // MARK: - Navigation and Routing
    static var navigationApiKey: String {
        ProcessInfo.processInfo.environment["NAVIGATION_API_KEY"] ?? ""
    }
    
    static var graphqlEndpoint: String {
        ProcessInfo.processInfo.environment["GRAPHQL_ENDPOINT"] ?? ""
    }
    
    static var graphqlAuthToken: String {
        ProcessInfo.processInfo.environment["GRAPHQL_AUTH_TOKEN"] ?? ""
    }
    
    // MARK: - Backend Configuration
    static var apiBaseUrl: String {
        ProcessInfo.processInfo.environment["API_BASE_URL"] ?? ""
    }
    
    static var apiAuthToken: String {
        ProcessInfo.processInfo.environment["API_AUTH_TOKEN"] ?? ""
    }
    
    // MARK: - Real-Time Updates
    static var realtimeApiUrl: String {
        ProcessInfo.processInfo.environment["REALTIME_API_URL"] ?? ""
    }
    
    static var realtimeApiKey: String {
        ProcessInfo.processInfo.environment["REALTIME_API_KEY"] ?? ""
    }
    
    // MARK: - App Configuration
    static var isDevelopment: Bool {
        ProcessInfo.processInfo.environment["APP_ENV"]?.lowercased() == "development"
    }
    
    // MARK: - Firebase
    static var firebaseApiKey: String {
        ProcessInfo.processInfo.environment["FIREBASE_API_KEY"] ?? ""
    }
    
    static var firebaseProjectId: String {
        ProcessInfo.processInfo.environment["FIREBASE_PROJECT_ID"] ?? ""
    }
    
    static var firebaseMessagingSenderId: String {
        ProcessInfo.processInfo.environment["FIREBASE_MESSAGING_SENDER_ID"] ?? ""
    }
    
    static var firebaseAppId: String {
        ProcessInfo.processInfo.environment["FIREBASE_APP_ID"] ?? ""
    }
    
    // MARK: - Analytics and Logging
    static var googleAnalyticsKey: String {
        ProcessInfo.processInfo.environment["GOOGLE_ANALYTICS_KEY"] ?? ""
    }
    
    static var sentryDsn: String {
        ProcessInfo.processInfo.environment["SENTRY_DSN"] ?? ""
    }
    
    // MARK: - Custom Configuration
    static var custom3dModelUrl: String {
        ProcessInfo.processInfo.environment["CUSTOM_3D_MODEL_URL"] ?? ""
    }
    
    // MARK: - Validation
    
    /// Validates that all required environment variables are present
    static func validateRequiredVariables() throws {
        let requiredVariables = [
            ("MAPBOX_ACCESS_TOKEN", mapboxAccessToken),
            ("WEATHER_UNLOCKED_API_KEY", weatherUnlockedApiKey),
            ("WEATHER_UNLOCKED_APP_ID", weatherUnlockedAppId),
            ("SKI_API_KEY", skiApiKey)
        ]
        
        let missingVariables = requiredVariables
            .filter { $0.1.isEmpty }
            .map { $0.0 }
        
        guard missingVariables.isEmpty else {
            throw EnvConfigError.missingRequiredVariables(missingVariables)
        }
    }
}

// MARK: - Error Types

enum EnvConfigError: LocalizedError {
    case missingRequiredVariables([String])
    
    var errorDescription: String? {
        switch self {
        case .missingRequiredVariables(let variables):
            return "Missing required environment variables: \(variables.joined(separator: ", "))"
        }
    }
} 

### File: App/SkiTrails/Utils/MapConfig.swift
import Foundation

enum MapConfig {
    enum MapConfigError: LocalizedError {
        case missingAccessToken
        
        var errorDescription: String? {
            switch self {
            case .missingAccessToken:
                return "Missing Mapbox access token"
            }
        }
    }
    
    static func getMapboxAccessToken() throws -> String {
        if let token = ProcessInfo.processInfo.environment["MAPBOX_ACCESS_TOKEN"] {
            return token
        }
        if let token = Bundle.main.object(forInfoDictionaryKey: "MGLMapboxAccessToken") as? String {
            return token
        }
        throw MapConfigError.missingAccessToken
    }
} 

### File: App/SkiTrails/Models/AppState.swift
import SwiftUI
import Combine
import CoreLocation
import Foundation

// Import ViewModels
@_spi(Internal) import SkiTrailsCore

@MainActor
class AppState: ObservableObject {
    // MARK: - Published Properties
    
    @Published var locationManager = LocationManager()
    @Published var selectedResort: Resort?
    @Published var selectedDifficulty: SkiTrailsCore.SkiDifficulty?
    @Published var isLoading = false
    @Published var error: UserFacingError?
    
    // Navigation state
    @Published var navigationPath = NavigationPath()
    @Published var activeRoute: Route?
    
    // Route coordinates for navigation
    @Published var routeCoordinates: [CLLocationCoordinate2D] = []
    
    // User preferences
    @Published var userSkillLevel: SkiTrailsCore.SkiDifficulty = .beginner
    @Published var preferLessStrenuous = false
    @Published var avoidCrowdedRuns = false
    
    // MARK: - Private Properties
    
    private var cancellables = Set<AnyCancellable>()
    private let errorHandler = ErrorHandler.shared
    private var statusRefreshTask: Task<Void, Never>?
    
    // MARK: - Initialization
    
    init() {
        setupSubscriptions()
        startStatusRefreshTimer()
        locationManager.requestAuthorization()
    }
    
    deinit {
        statusRefreshTask?.cancel()
    }
    
    // MARK: - Public Methods
    
    func clearError() {
        error = nil
    }
    
    func setLoading(_ loading: Bool) {
        isLoading = loading
    }
    
    func handleError(_ error: Error, context: ErrorContext? = nil) async {
        self.error = await errorHandler.handleUserFacing(error, context: context)
    }
    
    // MARK: - Resort Data
    
    func loadResort(id: String) async {
        setLoading(true)
        defer { setLoading(false) }
        
        do {
            // Fetch resort info
            let resort = try await APIClient.shared.fetchResortInfo(id: id)
            
            // Debug logging
            if EnvConfig.isDebugMode {
                print("\n=== Resort Data Debug Info ===")
                print("Resort: \(resort.name)")
                print("Location: (\(resort.location.latitude), \(resort.location.longitude))")
                print("\nLifts (\(resort.lifts.count)):")
                for lift in resort.lifts {
                    print("- \(lift.name) at (\(lift.latitude), \(lift.longitude))")
                }
                print("\nRuns (\(resort.runs.count)):")
                for run in resort.runs {
                    print("- \(run.name) (\(run.difficulty))")
                    print("  Top: (\(run.topLatitude), \(run.topLongitude))")
                    print("  Bottom: (\(run.bottomLatitude), \(run.bottomLongitude))")
                    print("  Length: \(run.length)m, Drop: \(run.verticalDrop)m")
                }
                print("==============================\n")
            }
            
            // Start async tasks for weather and lift status
            async let weather = APIClient.shared.fetchWeather(for: resort)
            async let lifts = APIClient.shared.fetchLiftStatus(for: resort)
            
            // Wait for all data
            var updatedResort = resort
            updatedResort.weather = try await weather
            updatedResort.lifts = try await lifts
            
            // Update state
            selectedResort = updatedResort
            
            // Initialize routing engine with resort data
            await RoutingEngine.shared.buildGraph(for: updatedResort)
            
            // Debug print the graph
            if EnvConfig.isDebugMode {
                await RoutingEngine.shared.debugPrintGraph()
            }
            
        } catch {
            await handleError(error, context: .api(endpoint: "resort/\(id)"))
        }
    }
    
    func refreshResortStatus() async {
        guard let resort = selectedResort else { return }
        
        do {
            // Re-fetch only the lifts for now, since we have no separate runs status API
            let updatedLifts = try await APIClient.shared.fetchLiftStatus(for: resort)
            
            // Merge updates
            var updatedResort = resort
            updatedResort.lifts = updatedLifts
            
            // Update state
            selectedResort = updatedResort
            
            // Re-build graph so closed lifts are excluded from routing
            await RoutingEngine.shared.buildGraph(for: updatedResort)
            
            if EnvConfig.isDebugMode {
                print("[Status Refresh] Lifts updated at \(Date())")
                await RoutingEngine.shared.debugPrintGraph()
            }
        } catch {
            await handleError(error, context: .api(endpoint: "refreshStatus"))
        }
    }
    
    // MARK: - Navigation
    
    func startNavigation(
        from startPoint: CLLocationCoordinate2D,
        to endPoint: CLLocationCoordinate2D
    ) async {
        do {
            guard let resort = selectedResort else {
                throw RoutingError.graphNotInitialized
            }
            
            // Calculate route
            let route = try await RoutingEngine.shared.findRoute(
                from: startPoint,
                to: endPoint,
                difficulty: userSkillLevel,
                preferences: RoutePreferences(
                    avoidCrowds: avoidCrowdedRuns,
                    preferLessStrenuous: preferLessStrenuous,
                    maxWaitTime: nil
                )
            )
            
            // Extract coordinates from route segments
            let routeCoordinates = route.segments.flatMap { segment in
                segment.path.map { location in
                    CLLocationCoordinate2D(
                        latitude: location.latitude,
                        longitude: location.longitude
                    )
                }
            }
            
            // Update state
            activeRoute = route
            self.routeCoordinates = routeCoordinates
            
        } catch {
            await handleError(
                error,
                context: .navigation(
                    startPoint: startPoint,
                    endPoint: endPoint,
                    difficulty: userSkillLevel
                )
            )
        }
    }
    
    func endNavigation() {
        activeRoute = nil
        routeCoordinates = []
    }
    
    // MARK: - Private Methods
    
    private func setupSubscriptions() {
        // Add Combine subscriptions for real-time updates
        // For example, periodic weather updates or lift status changes
    }
    
    private func startStatusRefreshTimer() {
        // Cancel any existing task
        statusRefreshTask?.cancel()
        
        // Start a new refresh task
        statusRefreshTask = Task {
            while !Task.isCancelled {
                do {
                    // Wait 60 seconds between refreshes
                    try await Task.sleep(nanoseconds: 60_000_000_000)
                    await refreshResortStatus()
                } catch {
                    // If Task is cancelled or fails, break the loop
                    break
                }
            }
        }
    }
}

// MARK: - Supporting Types
struct Resort: Identifiable, Codable {
    let id: String
    let name: String
    let location: Location
    var lifts: [Lift]
    var runs: [Run]
    var weather: WeatherInfo?
    
    struct Location: Codable {
        let latitude: Double
        let longitude: Double
        let altitude: Double
    }
}

struct Lift: Identifiable, Codable {
    let id: String
    let name: String
    var status: Status
    let capacity: Int
    let waitTime: Int?
    let latitude: Double
    let longitude: Double
    
    enum Status: String, Codable {
        case open
        case closed
        case hold
        case scheduled
    }
}

struct Run: Identifiable, Codable {
    let id: String
    let name: String
    let difficulty: SkiTrailsCore.SkiDifficulty
    var status: Status
    let length: Double // in meters
    let verticalDrop: Double // in meters
    let latitude: Double
    let longitude: Double
    let topLatitude: Double
    let topLongitude: Double
    let bottomLatitude: Double
    let bottomLongitude: Double
    
    enum Status: String, Codable {
        case open
        case closed
        case grooming
    }
    
    init(id: String, name: String, difficulty: SkiTrailsCore.SkiDifficulty, status: Status = .open,
         length: Double, verticalDrop: Double, latitude: Double, longitude: Double,
         topLatitude: Double? = nil, topLongitude: Double? = nil,
         bottomLatitude: Double? = nil, bottomLongitude: Double? = nil) {
        self.id = id
        self.name = name
        self.difficulty = difficulty
        self.status = status
        self.length = length
        self.verticalDrop = verticalDrop
        self.latitude = latitude
        self.longitude = longitude
        self.topLatitude = topLatitude ?? latitude
        self.topLongitude = topLongitude ?? longitude
        self.bottomLatitude = bottomLatitude ?? latitude
        self.bottomLongitude = bottomLongitude ?? longitude
    }
    
    enum CodingKeys: String, CodingKey {
        case id, name, difficulty, status, length, verticalDrop
        case latitude, longitude
        case topLatitude, topLongitude
        case bottomLatitude, bottomLongitude
    }
    
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        id = try container.decode(String.self, forKey: .id)
        name = try container.decode(String.self, forKey: .name)
        difficulty = try container.decode(SkiTrailsCore.SkiDifficulty.self, forKey: .difficulty)
        status = try container.decode(Status.self, forKey: .status)
        length = try container.decode(Double.self, forKey: .length)
        verticalDrop = try container.decode(Double.self, forKey: .verticalDrop)
        latitude = try container.decode(Double.self, forKey: .latitude)
        longitude = try container.decode(Double.self, forKey: .longitude)
        
        // Try to decode top/bottom coordinates, fall back to main coordinates
        topLatitude = try container.decodeIfPresent(Double.self, forKey: .topLatitude) ?? latitude
        topLongitude = try container.decodeIfPresent(Double.self, forKey: .topLongitude) ?? longitude
        bottomLatitude = try container.decodeIfPresent(Double.self, forKey: .bottomLatitude) ?? latitude
        bottomLongitude = try container.decodeIfPresent(Double.self, forKey: .bottomLongitude) ?? longitude
    }
    
    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(id, forKey: .id)
        try container.encode(name, forKey: .name)
        try container.encode(difficulty, forKey: .difficulty)
        try container.encode(status, forKey: .status)
        try container.encode(length, forKey: .length)
        try container.encode(verticalDrop, forKey: .verticalDrop)
        try container.encode(latitude, forKey: .latitude)
        try container.encode(longitude, forKey: .longitude)
        try container.encode(topLatitude, forKey: .topLatitude)
        try container.encode(topLongitude, forKey: .topLongitude)
        try container.encode(bottomLatitude, forKey: .bottomLatitude)
        try container.encode(bottomLongitude, forKey: .bottomLongitude)
    }
}

struct WeatherInfo: Codable {
    let temperature: Double
    let snowDepth: Double
    let windSpeed: Double
    let visibility: Double
    let forecast: String
    let lastUpdated: Date
}

struct Route {
    let segments: [Segment]
    let totalDistance: Double
    let estimatedTime: TimeInterval
    let difficulty: SkiTrailsCore.SkiDifficulty
    
    struct Segment {
        let type: SegmentType
        let path: [Location]
        let distance: Double
        
        enum SegmentType {
            case run(Run)
            case lift(Lift)
            case connection
        }
        
        struct Location {
            let latitude: Double
            let longitude: Double
            let altitude: Double
        }
    }
} 

### File: App/SkiTrails/Models/HeavenlyData.swift
import Foundation
import MapboxMaps
import Combine

class HeavenlyData: ObservableObject {
    @Published private(set) var boundaries: String?
    @Published private(set) var runs: String?
    @Published private(set) var lifts: String?
    @Published private(set) var isLoading = false
    @Published private(set) var error: Error?
    
    private let dataService = ResortDataService()
    private var cancellables = Set<AnyCancellable>()
    
    static let shared = HeavenlyData()
    
    private init() {
        // Subscribe to data service updates
        dataService.$boundaries
            .assign(to: &$boundaries)
        
        dataService.$runs
            .assign(to: &$runs)
        
        dataService.$lifts
            .assign(to: &$lifts)
        
        dataService.$isLoading
            .assign(to: &$isLoading)
        
        dataService.$error
            .assign(to: &$error)
        
        // Fetch initial data
        fetchData()
    }
    
    func fetchData() {
        dataService.fetchResortData(resortId: "heavenly")
    }
    
    // Fallback data in case API is not available
    static let fallbackBoundaries: String = """
    {
        "type": "Feature",
        "geometry": {
            "type": "Polygon",
            "coordinates": [[
                [-119.9500, 38.9300],
                [-119.9500, 38.9400],
                [-119.9300, 38.9400],
                [-119.9300, 38.9300],
                [-119.9500, 38.9300]
            ]]
        },
        "properties": {
            "name": "Heavenly Mountain Resort"
        }
    }
    """
    
    static let fallbackRuns: String = """
    {
        "type": "FeatureCollection",
        "features": [
            {
                "type": "Feature",
                "geometry": {
                    "type": "Polygon",
                    "coordinates": [[
                        [-119.9400, 38.9350],
                        [-119.9400, 38.9370],
                        [-119.9380, 38.9370],
                        [-119.9380, 38.9350],
                        [-119.9400, 38.9350]
                    ]]
                },
                "properties": {
                    "name": "Ridge Run",
                    "difficulty": "blue",
                    "status": "open"
                }
            },
            {
                "type": "Feature",
                "geometry": {
                    "type": "Polygon",
                    "coordinates": [[
                        [-119.9380, 38.9350],
                        [-119.9380, 38.9370],
                        [-119.9360, 38.9370],
                        [-119.9360, 38.9350],
                        [-119.9380, 38.9350]
                    ]]
                },
                "properties": {
                    "name": "Orion's Run",
                    "difficulty": "black",
                    "status": "open"
                }
            },
            {
                "type": "Feature",
                "geometry": {
                    "type": "Polygon",
                    "coordinates": [[
                        [-119.9420, 38.9350],
                        [-119.9420, 38.9370],
                        [-119.9400, 38.9370],
                        [-119.9400, 38.9350],
                        [-119.9420, 38.9350]
                    ]]
                },
                "properties": {
                    "name": "Comet Run",
                    "difficulty": "green",
                    "status": "open"
                }
            }
        ]
    }
    """
    
    static let fallbackLifts: String = """
    {
        "type": "FeatureCollection",
        "features": [
            {
                "type": "Feature",
                "geometry": {
                    "type": "LineString",
                    "coordinates": [
                        [-119.9450, 38.9320],
                        [-119.9400, 38.9380]
                    ]
                },
                "properties": {
                    "name": "Gondola",
                    "type": "gondola",
                    "status": "operating"
                }
            },
            {
                "type": "Feature",
                "geometry": {
                    "type": "LineString",
                    "coordinates": [
                        [-119.9380, 38.9320],
                        [-119.9350, 38.9380]
                    ]
                },
                "properties": {
                    "name": "Comet Express",
                    "type": "chairlift",
                    "status": "operating"
                }
            }
        ]
    }
    """
} 

### File: App/SkiTrails/Models/Status.swift
import SwiftUI

enum Status: String, Codable {
    case open
    case closed
    case hold
    case scheduled
    case grooming
    
    var color: Color {
        switch self {
        case .open:
            return .green
        case .closed:
            return .red
        case .hold:
            return .orange
        case .scheduled:
            return .blue
        case .grooming:
            return .purple
        }
    }
} 

### File: App/SkiTrails/Models/TrailDifficulty.swift
import SwiftUI

enum TrailDifficulty: String, Codable {
    case beginner = "green"
    case intermediate = "blue"
    case advanced = "black"
    case expert = "double_black"
    
    var description: String {
        switch self {
        case .beginner:
            return "Beginner"
        case .intermediate:
            return "Intermediate"
        case .advanced:
            return "Advanced"
        case .expert:
            return "Expert"
        }
    }
} 

### File: App/SkiTrails/Extensions/SkiDifficulty+Color.swift
import SwiftUI
import SkiTrailsCore

extension SkiDifficulty {
    var color: Color {
        switch self {
        case .beginner:
            return .green
        case .intermediate:
            return .blue
        case .advanced:
            return .black
        case .expert:
            return .black
        }
    }
} 

### File: App/SkiTrails/Images.xcassets/Contents.json
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
} 

### File: App/SkiTrails/Images.xcassets/AppIcon.appiconset/Contents.json
{
  "images" : [
    {
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "20x20"
    },
    {
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "20x20"
    },
    {
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "29x29"
    },
    {
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "29x29"
    },
    {
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "40x40"
    },
    {
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "40x40"
    },
    {
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "60x60"
    },
    {
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "60x60"
    },
    {
      "idiom" : "ios-marketing",
      "scale" : "1x",
      "size" : "1024x1024"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
} 

### File: App/SkiTrails/Views/ARResortView.swift
import SwiftUI

struct ARResortView: View {
    var body: some View {
        ContentUnavailableView(
            "AR View Coming Soon",
            systemImage: "camera.viewfinder",
            description: Text("This feature is under development")
        )
    }
}

#Preview {
    ARResortView()
} 

### File: App/SkiTrails/Views/ActiveNavigationView.swift
import SwiftUI
import MapKit
import SkiTrailsCore

struct ActiveNavigationView: View {
    @ObservedObject var viewModel: NavigationViewModel
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        VStack(spacing: 0) {
            if let route = viewModel.currentRoute {
                RouteOverlayView(route: route)
                    .overlay(alignment: .topTrailing) {
                        Button(action: { viewModel.endNavigation() }) {
                            Image(systemName: "xmark.circle.fill")
                                .font(.title)
                                .foregroundColor(.secondary)
                                .padding()
                        }
                    }
                
                VStack(spacing: 16) {
                    HStack {
                        VStack(alignment: .leading) {
                            Text("Estimated Time")
                                .font(.caption)
                                .foregroundColor(.secondary)
                            Text(formatDuration(route.estimatedTime))
                                .font(.title2)
                                .bold()
                        }
                        
                        Spacer()
                        
                        VStack(alignment: .trailing) {
                            Text("Distance")
                                .font(.caption)
                                .foregroundColor(.secondary)
                            Text(String(format: "%.1f km", route.totalDistance / 1000))
                                .font(.title2)
                                .bold()
                        }
                    }
                    
                    Divider()
                    
                    ScrollView(.horizontal, showsIndicators: false) {
                        HStack(spacing: 12) {
                            ForEach(route.segments.indices, id: \.self) { index in
                                let segment = route.segments[index]
                                SegmentCard(
                                    segment: segment,
                                    isFirst: index == 0,
                                    isLast: index == route.segments.count - 1
                                )
                            }
                        }
                        .padding(.horizontal)
                    }
                }
                .padding()
                .background(.ultraThinMaterial)
            }
        }
        .navigationBarHidden(true)
        .ignoresSafeArea(edges: .top)
    }
    
    private func formatDuration(_ timeInterval: TimeInterval) -> String {
        let hours = Int(timeInterval) / 3600
        let minutes = Int(timeInterval) / 60 % 60
        
        if hours > 0 {
            return String(format: "%dh %dm", hours, minutes)
        } else {
            return String(format: "%d min", minutes)
        }
    }
}

struct SegmentCard: View {
    let segment: Route.Segment
    let isFirst: Bool
    let isLast: Bool
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                Image(systemName: iconName)
                    .font(.title2)
                
                Text(title)
                    .font(.headline)
            }
            
            Text(String(format: "%.0f m", segment.distance))
                .font(.subheadline)
                .foregroundColor(.secondary)
            
            if case .run(let run) = segment.type {
                DifficultyIndicator(difficulty: run.difficulty)
            }
        }
        .padding()
        .background(Color(.secondarySystemBackground))
        .cornerRadius(12)
    }
    
    private var iconName: String {
        if isFirst {
            return "location.circle.fill"
        } else if isLast {
            return "flag.circle.fill"
        } else {
            switch segment.type {
            case .run:
                return "arrow.down.circle.fill"
            case .lift:
                return "arrow.up.circle.fill"
            case .connection:
                return "arrow.right.circle.fill"
            }
        }
    }
    
    private var title: String {
        if isFirst {
            return "Start"
        } else if isLast {
            return "Finish"
        } else {
            switch segment.type {
            case .run(let run):
                return run.name
            case .lift(let lift):
                return lift.name
            case .connection:
                return "Connection"
            }
        }
    }
}

struct DifficultyIndicator: View {
    let difficulty: Run.Difficulty
    
    var body: some View {
        Text(difficulty.rawValue.capitalized)
            .font(.caption)
            .padding(.horizontal, 8)
            .padding(.vertical, 4)
            .background(difficultyColor.opacity(0.2))
            .foregroundColor(difficultyColor)
            .clipShape(Capsule())
    }
    
    private var difficultyColor: Color {
        switch difficulty {
        case .beginner:
            return .green
        case .intermediate:
            return .blue
        case .advanced:
            return .black
        case .expert:
            return .purple
        }
    }
}

#Preview {
    ActiveNavigationView(viewModel: NavigationViewModel())
} 

### File: App/SkiTrails/Views/ContentView.swift
import SwiftUI
import MapKit
import SkiTrailsCore
import CoreLocation

struct ContentView: View {
    @EnvironmentObject private var appState: AppState
    @State private var selectedTab = 0
    
    var body: some View {
        if #available(iOS 16.0, *) {
            NavigationStack {
                mainContent
            }
        } else {
            NavigationView {
                mainContent
            }.navigationViewStyle(.stack)
        }
    }
    
    private var mainContent: some View {
        TabView(selection: $selectedTab) {
            ResortListView()
                .tabItem { Label("Resorts", systemImage: "mountain.2") }
                .tag(0)
            
            MapView()
                .tabItem { Label("Map", systemImage: "map") }
                .tag(1)
            
            TrailStatusView()
                .tabItem { Label("Trails", systemImage: "figure.skiing.downhill") }
                .tag(2)
            
            NavigationView {
                NavigationSetupView(viewModel: NavigationViewModel())
            }
            .tabItem { Label("Navigation", systemImage: "location.north.circle") }
            .tag(3)
            
            ARResortView()
                .tabItem { Label("AR View", systemImage: "camera.viewfinder") }
                .tag(4)
        }
    }
}

struct ResortListView: View {
    @StateObject private var viewModel = ResortViewModel()
    @EnvironmentObject private var appState: AppState
    
    var body: some View {
        Group {
            if viewModel.isLoading {
                ProgressView()
            } else {
                List {
                    ForEach(appState.resorts) { resort in
                        ResortRowView(resort: resort)
                            .onTapGesture {
                                viewModel.selectResort(resort)
                            }
                    }
                }
            }
        }
        .navigationTitle("Ski Resorts")
        .task {
            await appState.loadResorts()
        }
        .alert(
            "Error",
            isPresented: Binding(
                get: { viewModel.error != nil },
                set: { if !$0 { viewModel.error = nil } }
            )
        ) { _ in
            Button("OK", role: .cancel) {}
        } message: { error in
            Text(error.localizedDescription)
        }
    }
}

struct ResortRowView: View {
    let resort: Resort
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text(resort.name)
                .font(.headline)
            
            if let weather = resort.weather {
                HStack {
                    Image(systemName: "thermometer")
                    Text("\(Int(weather.temperature))°F")
                    Text("•")
                    Text(weather.conditions)
                }
                .font(.subheadline)
                .foregroundColor(.secondary)
            }
            
            HStack {
                StatusIndicator(
                    count: resort.lifts.filter { $0.status == .open }.count,
                    total: resort.lifts.count,
                    type: "Lifts"
                )
                
                Spacer()
                
                StatusIndicator(
                    count: resort.runs.filter { $0.status == .open }.count,
                    total: resort.runs.count,
                    type: "Runs"
                )
            }
            .padding(.top, 4)
        }
        .padding(.vertical, 8)
    }
}

struct StatusIndicator: View {
    let count: Int
    let total: Int
    let type: String
    
    var body: some View {
        HStack(spacing: 4) {
            Circle()
                .fill(count > 0 ? .green : .red)
                .frame(width: 8, height: 8)
            
            Text("\(count)/\(total) \(type)")
                .font(.caption)
                .foregroundColor(.secondary)
        }
    }
}

struct MapView: View {
    @StateObject private var viewModel = MapViewModel()
    
    var body: some View {
        ZStack(alignment: .bottom) {
            Map(coordinateRegion: $viewModel.region) {
                if let resort = viewModel.selectedResort {
                    Marker(resort.name, coordinate: CLLocationCoordinate2D(
                        latitude: resort.location.latitude,
                        longitude: resort.location.longitude
                    ))
                }
            }
            
            if let resort = viewModel.selectedResort {
                ResortDetailCard(resort: resort)
                    .padding()
                    .transition(.move(edge: .bottom))
            }
        }
        .navigationTitle("Resort Map")
        .animation(.spring(), value: viewModel.selectedResort)
    }
}

struct ResortDetailCard: View {
    let resort: Resort
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text(resort.name)
                .font(.headline)
            
            if let weather = resort.weather {
                HStack {
                    Image(systemName: "thermometer")
                    Text("\(Int(weather.temperature))°F")
                    Text("•")
                    Text(weather.conditions)
                }
                .font(.subheadline)
                .foregroundColor(.secondary)
            }
        }
        .padding()
        .background(.ultraThinMaterial)
        .cornerRadius(10)
    }
}

struct TrailStatusView: View {
    @EnvironmentObject private var appState: AppState
    @StateObject private var viewModel = ResortViewModel()
    
    var body: some View {
        Group {
            if viewModel.isLoading {
                ProgressView()
            } else if let resort = viewModel.selectedResort {
                List {
                    Section("Lifts") {
                        ForEach(resort.lifts) { lift in
                            LiftStatusRow(lift: lift)
                        }
                    }
                    
                    Section("Runs") {
                        ForEach(resort.runs) { run in
                            RunStatusRow(run: run)
                        }
                    }
                }
            } else {
                ContentUnavailableView(
                    "No Resort Selected",
                    systemImage: "mountain.2",
                    description: Text("Select a resort to view trail status")
                )
            }
        }
        .navigationTitle("Trail Status")
        .refreshable {
            if let resort = viewModel.selectedResort {
                await viewModel.selectResort(resort)
            }
        }
    }
}

struct LiftStatusRow: View {
    let lift: Lift
    
    var body: some View {
        HStack {
            Text(lift.name)
            
            Spacer()
            
            StatusBadge(status: lift.status)
        }
    }
}

struct RunStatusRow: View {
    let run: Run
    
    var body: some View {
        HStack {
            VStack(alignment: .leading) {
                Text(run.name)
                
                HStack {
                    DifficultyIndicator(difficulty: run.difficulty)
                    Text("\(Int(run.length))m • \(Int(run.verticalDrop))m vert")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
            }
            
            Spacer()
            
            StatusBadge(status: run.status)
        }
    }
}

struct StatusBadge: View {
    let status: Status
    
    var body: some View {
        Text(status.rawValue.capitalized)
            .font(.caption)
            .padding(.horizontal, 8)
            .padding(.vertical, 4)
            .background(status.color.opacity(0.2))
            .foregroundColor(status.color)
            .clipShape(Capsule())
    }
}

#Preview {
    ContentView()
        .environmentObject(AppState())
} 

### File: App/SkiTrails/Views/ErrorAlertView.swift
import SwiftUI

struct ErrorAlertView: View {
    let error: UserFacingError
    let dismissAction: () -> Void
    
    var body: some View {
        VStack {
            Spacer()
            
            VStack(spacing: 16) {
                // Error Icon
                Image(systemName: "exclamationmark.triangle.fill")
                    .font(.largeTitle)
                    .foregroundColor(.red)
                
                // Error Title
                Text(error.title)
                    .font(.headline)
                
                // Error Message
                Text(error.message)
                    .font(.subheadline)
                    .multilineTextAlignment(.center)
                
                // Recovery Suggestion
                if let suggestion = error.recoverySuggestion {
                    Text(suggestion)
                        .font(.caption)
                        .foregroundColor(.secondary)
                        .multilineTextAlignment(.center)
                }
                
                // Dismiss Button
                Button("Dismiss") {
                    dismissAction()
                }
                .buttonStyle(.borderedProminent)
            }
            .padding()
            .background(.ultraThinMaterial)
            .cornerRadius(10)
            .padding()
            
            Spacer()
        }
        .background(Color.black.opacity(0.4))
        .ignoresSafeArea()
    }
}

// MARK: - Preview

#Preview {
    ErrorAlertView(
        error: UserFacingError(
            title: "Network Error",
            message: "Failed to load resort data",
            recoverySuggestion: "Please check your internet connection and try again."
        )
    ) {
        // Dismiss action
    }
} 

### File: App/SkiTrails/Views/MapSelectionView.swift
import SwiftUI
import MapKit
import CoreLocation

struct MapSelectionView: View {
    @Environment(\.dismiss) private var dismiss
    @Binding var coordinate: CLLocationCoordinate2D?
    let title: String
    
    @State private var region = MKCoordinateRegion(
        center: CLLocationCoordinate2D(latitude: 37.7749, longitude: -122.4194),
        span: MKCoordinateSpan(latitudeDelta: 0.1, longitudeDelta: 0.1)
    )
    
    private var annotations: [IdentifiableCoordinate] {
        if let coordinate = coordinate {
            return [IdentifiableCoordinate(coordinate: coordinate)]
        }
        return []
    }
    
    var body: some View {
        NavigationView {
            Map(coordinateRegion: $region,
                annotationItems: annotations) { item in
                MapMarker(coordinate: item.coordinate)
            }
            .onTapGesture { _ in
                withAnimation {
                    coordinate = region.center
                }
            }
            .navigationTitle(title)
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") { dismiss() }
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("Done") { dismiss() }
                    .disabled(coordinate == nil)
                }
            }
        }
    }
}

private struct IdentifiableCoordinate: Identifiable {
    let id = UUID()
    let coordinate: CLLocationCoordinate2D
}

#Preview {
    MapSelectionView(
        coordinate: .constant(nil),
        title: "Select Location"
    )
} 

### File: App/SkiTrails/Views/MapView.swift
import SwiftUI
import MapboxMaps
import SkiTrailsCore

struct MapView: View {
    @StateObject private var viewModel = MapViewModel()
    @EnvironmentObject private var appState: AppState
    
    var body: some View {
        ZStack {
            MapViewRepresentable(
                selectedFeature: $viewModel.selectedFeature
            )
            
            if let feature = viewModel.selectedFeature {
                VStack {
                    Spacer()
                    FeatureDetailCard(feature: feature)
                        .padding()
                }
            }
        }
        .edgesIgnoringSafeArea(.all)
    }
}

struct MapViewRepresentable: UIViewControllerRepresentable {
    @Binding var selectedFeature: MapFeature?
    
    func makeUIViewController(context: Context) -> MapViewController {
        let viewController = MapViewController()
        viewController.delegate = context.coordinator
        return viewController
    }
    
    func updateUIViewController(_ uiViewController: MapViewController, context: Context) {
        // Update view controller if needed
    }
    
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    
    class Coordinator: NSObject, MapViewControllerDelegate {
        var parent: MapViewRepresentable
        
        init(_ parent: MapViewRepresentable) {
            self.parent = parent
        }
        
        func mapViewController(_ controller: MapViewController, didSelect feature: MapFeature) {
            parent.selectedFeature = feature
        }
    }
}

class MapViewController: UIViewController {
    weak var delegate: MapViewControllerDelegate?
    private var mapView: MapView?
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setupMapView()
    }
    
    private func setupMapView() {
        do {
            let accessToken = try MapConfig.getMapboxAccessToken()
            let resourceOptions = ResourceOptions(accessToken: accessToken)
            let mapInitOptions = MapInitOptions(resourceOptions: resourceOptions)
            
            let mapView = MapView(frame: view.bounds, mapInitOptions: mapInitOptions)
            mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight]
            
            view.addSubview(mapView)
            self.mapView = mapView
            
            // Configure map style and camera
            mapView.mapboxMap.loadStyleURI(.outdoors)
            
            // Set initial camera position
            let camera = CameraOptions(
                center: CLLocationCoordinate2D(latitude: 39.6403, longitude: -106.3742),
                zoom: 14,
                bearing: 0,
                pitch: 45
            )
            mapView.camera.fly(to: camera, duration: 0)
            
        } catch {
            print("Failed to initialize map: \(error.localizedDescription)")
        }
    }
}

protocol MapViewControllerDelegate: AnyObject {
    func mapViewController(_ controller: MapViewController, didSelect feature: MapFeature)
}

struct FeatureDetailCard: View {
    let feature: MapFeature
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text(feature.name)
                .font(.headline)
            
            switch feature {
            case .run(let run):
                RunDetailView(run: run)
            case .lift(let lift):
                LiftDetailView(lift: lift)
            case .point(_, _, _):
                EmptyView()
            }
        }
        .padding()
        .background(Color(.systemBackground))
        .cornerRadius(12)
        .shadow(radius: 5)
    }
}

struct RunDetailView: View {
    let run: Run
    
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            HStack {
                Text("Difficulty:")
                Text(run.difficulty.rawValue.capitalized)
            }
            HStack {
                Text("Status:")
                Text(run.status.rawValue.capitalized)
            }
            HStack {
                Text("Length:")
                Text(String(format: "%.1f km", run.length / 1000))
            }
            HStack {
                Text("Vertical:")
                Text(String(format: "%.0f m", run.verticalDrop))
            }
        }
    }
}

struct LiftDetailView: View {
    let lift: Lift
    
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            HStack {
                Text("Status:")
                Text(lift.status.rawValue.capitalized)
            }
            HStack {
                Text("Capacity:")
                Text("\(lift.capacity) riders")
            }
            if let waitTime = lift.waitTime {
                HStack {
                    Text("Wait Time:")
                    Text(String(format: "%.0f min", waitTime / 60))
                }
            }
        }
    }
} 

### File: App/SkiTrails/Views/MapboxMapView.swift
import SwiftUI
import MapboxMaps
import CoreLocation
import SkiTrailsCore
import UIKit

struct MapboxMapView: UIViewRepresentable {
    typealias UIViewType = UIView
    
    let initialCoordinates: CLLocationCoordinate2D
    let initialZoom: Double
    let initialPitch: Double
    let initialBearing: Double
    @Binding var selectedFeature: MapFeature?
    
    func makeUIView(context: Context) -> UIView {
        let resourceOptions = ResourceOptions(accessToken: EnvConfig.mapboxAccessToken)
        let cameraOptions = CameraOptions(
            center: initialCoordinates,
            zoom: initialZoom,
            bearing: initialBearing,
            pitch: initialPitch
        )
        let initOptions = MapInitOptions(resourceOptions: resourceOptions,
                                       cameraOptions: cameraOptions)
        
        let containerView = UIView()
        containerView.autoresizingMask = [UIView.AutoresizingMask.flexibleWidth, UIView.AutoresizingMask.flexibleHeight]
        
        let mapView = MapView(frame: containerView.bounds, mapInitOptions: initOptions)
        mapView.autoresizingMask = [UIView.AutoresizingMask.flexibleWidth, UIView.AutoresizingMask.flexibleHeight]
        containerView.addSubview(mapView)
        
        // Store mapView in coordinator for later access
        context.coordinator.mapView = mapView
        
        // Observe style loaded event
        mapView.mapboxMap.onStyleLoaded.observe { _ in
            // Map style finished loading
        }
        
        return containerView
    }
    
    func updateUIView(_ uiView: UIView, context: Context) {
        // Access mapView through coordinator
        guard let mapView = context.coordinator.mapView else { return }
        // Update map view state as needed
    }
    
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    
    class Coordinator: NSObject {
        var parent: MapboxMapView
        var mapView: MapView?
        
        init(_ parent: MapboxMapView) {
            self.parent = parent
        }
    }
} 

### File: App/SkiTrails/Views/NavigationSetupView.swift
import SwiftUI
import CoreLocation
import SkiTrailsCore

struct NavigationSetupView: View {
    @ObservedObject var viewModel: NavigationViewModel
    @EnvironmentObject private var appState: AppState
    @State private var selectedDifficulty: SkiDifficulty = .intermediate
    @State private var avoidCrowds = false
    @State private var preferLessStrenuous = false
    @State private var maxWaitTime: TimeInterval = 900 // 15 minutes
    
    var body: some View {
        if viewModel.isNavigating {
            ActiveNavigationView(viewModel: viewModel)
        } else {
            setupView
        }
    }
    
    private var setupView: some View {
        Form {
            Section("Difficulty") {
                Picker("Maximum Difficulty", selection: $selectedDifficulty) {
                    ForEach(SkiDifficulty.allCases, id: \.self) { difficulty in
                        Text(difficulty.rawValue.capitalized)
                            .tag(difficulty)
                    }
                }
            }
            
            Section("Preferences") {
                Toggle("Avoid Crowded Runs", isOn: $avoidCrowds)
                Toggle("Prefer Less Strenuous Routes", isOn: $preferLessStrenuous)
                
                VStack(alignment: .leading) {
                    Text("Maximum Lift Wait Time")
                    Slider(
                        value: $maxWaitTime,
                        in: 300...1800, // 5-30 minutes
                        step: 300
                    ) {
                        Text("Max Wait Time")
                    } minimumValueLabel: {
                        Text("5m")
                    } maximumValueLabel: {
                        Text("30m")
                    }
                    Text("\(Int(maxWaitTime/60)) minutes")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
            }
            
            Section {
                Button(action: startNavigation) {
                    if viewModel.isCalculating {
                        ProgressView()
                            .progressViewStyle(.circular)
                    } else {
                        Text("Start Navigation")
                    }
                }
                .disabled(viewModel.isCalculating)
            }
        }
        .navigationTitle("Navigation Setup")
        .alert("Navigation Error", isPresented: .constant(viewModel.error != nil)) {
            Button("OK", role: .cancel) {}
        } message: {
            if let error = viewModel.error {
                Text(error.localizedDescription)
            }
        }
    }
    
    private func startNavigation() {
        Task {
            guard let start = appState.currentLocation?.coordinate,
                  let end = appState.selectedDestination?.coordinate else {
                return
            }
            
            let preferences = RoutePreferences(
                avoidCrowds: avoidCrowds,
                preferLessStrenuous: preferLessStrenuous,
                maxWaitTime: maxWaitTime
            )
            
            await viewModel.startNavigation(
                from: start,
                to: end,
                difficulty: selectedDifficulty,
                preferences: preferences
            )
        }
    }
}

#Preview {
    NavigationSetupView(viewModel: NavigationViewModel())
        .environmentObject(AppState())
} 

### File: App/SkiTrails/Views/RouteDetailView.swift
import SwiftUI
import SkiTrailsCore

struct RouteDetailView: View {
    let route: Route
    @Environment(\.dismiss) private var dismiss
    @EnvironmentObject private var appState: AppState
    
    var body: some View {
        List {
            // Route Summary
            Section {
                VStack(alignment: .leading, spacing: 8) {
                    HStack {
                        Label("\(Int(route.totalDistance))m", systemName: "ruler")
                        Spacer()
                        Label(formatDuration(route.estimatedTime), systemName: "clock")
                    }
                    
                    HStack {
                        Label("Difficulty", systemName: "figure.skiing.downhill")
                        Spacer()
                        DifficultyIndicator(difficulty: route.difficulty)
                    }
                }
            }
            
            // Route Segments
            Section("Route Details") {
                ForEach(route.segments.indices, id: \.self) { index in
                    let segment = route.segments[index]
                    RouteSegmentRow(segment: segment, index: index)
                }
            }
            
            // Actions
            Section {
                Button(action: {
                    startNavigation()
                }) {
                    Label("Start Navigation", systemName: "location.fill")
                }
                .foregroundColor(.blue)
                
                Button(action: {
                    shareRoute()
                }) {
                    Label("Share Route", systemName: "square.and.arrow.up")
                }
            }
        }
        .navigationTitle("Route Details")
        .navigationBarTitleDisplayMode(.inline)
        .toolbar {
            ToolbarItem(placement: .navigationBarTrailing) {
                Button("Done") {
                    dismiss()
                }
            }
        }
    }
    
    private func formatDuration(_ timeInterval: TimeInterval) -> String {
        let formatter = DateComponentsFormatter()
        formatter.allowedUnits = [.hour, .minute]
        formatter.unitsStyle = .abbreviated
        return formatter.string(from: timeInterval) ?? ""
    }
    
    private func startNavigation() {
        appState.activeRoute = route
        dismiss()
    }
    
    private func shareRoute() {
        // Implement route sharing functionality
    }
}

struct RouteSegmentRow: View {
    let segment: Route.Segment
    let index: Int
    
    var body: some View {
        HStack(spacing: 12) {
            // Segment number
            ZStack {
                Circle()
                    .fill(.blue)
                    .frame(width: 24, height: 24)
                Text("\(index + 1)")
                    .foregroundColor(.white)
                    .font(.caption.bold())
            }
            
            // Segment details
            VStack(alignment: .leading, spacing: 4) {
                Text(segmentTitle)
                    .font(.headline)
                Text("\(Int(segment.distance))m")
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }
            
            Spacer()
            
            // Segment icon
            Image(systemName: segmentIcon)
                .foregroundColor(.blue)
        }
        .padding(.vertical, 4)
    }
    
    private var segmentTitle: String {
        switch segment.type {
        case .run(let run):
            return run.name
        case .lift(let lift):
            return lift.name
        case .connection:
            return "Connection"
        }
    }
    
    private var segmentIcon: String {
        switch segment.type {
        case .run:
            return "figure.skiing.downhill"
        case .lift:
            return "arrow.up"
        case .connection:
            return "arrow.right"
        }
    }
}

struct DifficultyIndicator: View {
    let difficulty: SkiDifficulty
    
    var body: some View {
        HStack(spacing: 4) {
            Circle()
                .fill(difficulty.color)
                .frame(width: 12, height: 12)
            Text(difficulty.rawValue)
                .font(.subheadline)
        }
    }
}

#if DEBUG
struct RouteDetailView_Previews: PreviewProvider {
    static var previews: some View {
        NavigationView {
            RouteDetailView(route: .preview)
                .environmentObject(AppState())
        }
    }
}
#endif

// MARK: - Preview Helpers
extension Route {
    static var preview: Route {
        let location1 = Location(latitude: 0, longitude: 0, elevation: 0)
        let location2 = Location(latitude: 1, longitude: 1, elevation: 100)
        let location3 = Location(latitude: 2, longitude: 2, elevation: 0)
        
        return Route(
            segments: [
                Segment(
                    type: .lift(Lift(
                        id: "1",
                        name: "Express Lift",
                        status: .open,
                        latitude: location1.latitude,
                        longitude: location1.longitude,
                        capacity: 4,
                        waitTime: 5
                    )),
                    path: [
                        location1,
                        location2
                    ],
                    distance: 1200
                ),
                Segment(
                    type: .run(Run(
                        id: "2",
                        name: "Blue Run",
                        difficulty: .intermediate,
                        status: .open,
                        length: 800,
                        verticalDrop: 200,
                        latitude: location2.latitude,
                        longitude: location2.longitude,
                        topLatitude: location2.latitude,
                        topLongitude: location2.longitude,
                        bottomLatitude: location3.latitude,
                        bottomLongitude: location3.longitude
                    )),
                    path: [
                        location2,
                        location3
                    ],
                    distance: 800
                )
            ],
            totalDistance: 2000,
            estimatedTime: 1800, // 30 minutes
            difficulty: .intermediate
        )
    }
} 

### File: App/SkiTrails/Views/RouteOverlayView.swift
import SwiftUI
import MapboxMaps
import SkiTrailsCore

struct RouteOverlayView: View {
    let route: Route
    @State private var mapView: MapView?
    
    var body: some View {
        MapViewRepresentable(route: route) { view in
            mapView = view
        }
        .onAppear {
            addRouteLayer()
        }
        .onChange(of: route) { _ in
            addRouteLayer()
        }
    }
    
    private func addRouteLayer() {
        guard let mapView = mapView else { return }
        
        // Convert route segments to GeoJSON
        var features: [Feature] = []
        
        for segment in route.segments {
            let coordinates = segment.path.map {
                CLLocationCoordinate2D(latitude: $0.latitude, longitude: $0.longitude)
            }
            
            var feature = Feature(geometry: .lineString(LineString(coordinates)))
            
            // Add properties based on segment type
            switch segment.type {
            case .run(let run):
                feature.properties = [
                    "type": .string("run"),
                    "difficulty": .string(run.difficulty.rawValue),
                    "name": .string(run.name)
                ]
            case .lift(let lift):
                feature.properties = [
                    "type": .string("lift"),
                    "name": .string(lift.name)
                ]
            case .connection:
                feature.properties = [
                    "type": .string("connection")
                ]
            }
            
            features.append(feature)
        }
        
        let source = GeoJSONSource(features: features)
        
        // Add source to map
        do {
            try mapView.mapboxMap.style.addSource(source, id: "route-source")
            
            // Add layer for runs
            try mapView.mapboxMap.style.addLayer(
                LineLayer(
                    id: "route-runs",
                    source: "route-source"
                ) { layer in
                    layer.filter = Exp(.eq) {
                        "$type"
                        "LineString"
                        Exp(.eq) {
                            Exp(.get) { "type" }
                            "run"
                        }
                    }
                    layer.lineColor = .constant(.init(UIColor.systemBlue))
                    layer.lineWidth = .constant(4)
                    layer.lineCap = .constant(.round)
                    layer.lineJoin = .constant(.round)
                }
            )
            
            // Add layer for lifts
            try mapView.mapboxMap.style.addLayer(
                LineLayer(
                    id: "route-lifts",
                    source: "route-source"
                ) { layer in
                    layer.filter = Exp(.eq) {
                        "$type"
                        "LineString"
                        Exp(.eq) {
                            Exp(.get) { "type" }
                            "lift"
                        }
                    }
                    layer.lineColor = .constant(.init(UIColor.systemRed))
                    layer.lineWidth = .constant(4)
                    layer.lineDasharray = .constant([2, 1])
                }
            )
            
            // Add layer for connections
            try mapView.mapboxMap.style.addLayer(
                LineLayer(
                    id: "route-connections",
                    source: "route-source"
                ) { layer in
                    layer.filter = Exp(.eq) {
                        "$type"
                        "LineString"
                        Exp(.eq) {
                            Exp(.get) { "type" }
                            "connection"
                        }
                    }
                    layer.lineColor = .constant(.init(UIColor.systemGray))
                    layer.lineWidth = .constant(2)
                    layer.lineDasharray = .constant([4, 2])
                }
            )
            
            // Fit map to route bounds
            let coordinates = route.segments.flatMap { $0.path }.map {
                CLLocationCoordinate2D(latitude: $0.latitude, longitude: $0.longitude)
            }
            let bounds = coordinates.reduce(CoordinateBounds(southwest: coordinates[0], northeast: coordinates[0])) {
                $0.extend(with: $1)
            }
            mapView.camera.fit(to: bounds, padding: UIEdgeInsets(top: 50, left: 50, bottom: 50, right: 50))
            
        } catch {
            print("Failed to add route layers: \(error.localizedDescription)")
        }
    }
}

private struct MapViewRepresentable: UIViewRepresentable {
    let route: Route
    let onViewCreated: (MapView) -> Void
    
    func makeUIView(context: Context) -> MapView {
        let accessToken = try! MapConfig.getMapboxAccessToken()
        let resourceOptions = ResourceOptions(accessToken: accessToken)
        let mapInitOptions = MapInitOptions(resourceOptions: resourceOptions)
        
        let mapView = MapView(frame: .zero, mapInitOptions: mapInitOptions)
        mapView.mapboxMap.loadStyleURI(.outdoors)
        
        onViewCreated(mapView)
        return mapView
    }
    
    func updateUIView(_ mapView: MapView, context: Context) {
        // Update view if needed
    }
}

#Preview {
    RouteOverlayView(route: Route(
        segments: [],
        totalDistance: 0,
        estimatedTime: 0,
        difficulty: .beginner
    ))
} 

### File: App/SkiTrails/Services/APIClient.swift
import Foundation
import CoreLocation
import SkiTrailsCore

enum APIError: Error {
    case invalidURL
    case invalidResponse
    case networkError(Error)
    case decodingError(Error)
    case serverError(Int)
    case unauthorized
    case unknown
    
    var localizedDescription: String {
        switch self {
        case .invalidURL:
            return "Invalid URL configuration"
        case .invalidResponse:
            return "Invalid server response"
        case .networkError(let error):
            return "Network error: \(error.localizedDescription)"
        case .decodingError(let error):
            return "Failed to decode response: \(error.localizedDescription)"
        case .serverError(let code):
            return "Server error with code: \(code)"
        case .unauthorized:
            return "Unauthorized access"
        case .unknown:
            return "An unknown error occurred"
        }
    }
}

actor APIClient {
    static let shared = APIClient()
    
    private let session: URLSession
    private let decoder: JSONDecoder
    private let encoder: JSONEncoder
    
    private init() {
        let configuration = URLSessionConfiguration.default
        configuration.timeoutIntervalForRequest = 30
        configuration.timeoutIntervalForResource = 300
        self.session = URLSession(configuration: configuration)
        
        self.decoder = JSONDecoder()
        self.decoder.keyDecodingStrategy = .convertFromSnakeCase
        self.decoder.dateDecodingStrategy = .iso8601
        
        self.encoder = JSONEncoder()
        self.encoder.keyEncodingStrategy = .convertToSnakeCase
        self.encoder.dateEncodingStrategy = .iso8601
    }
    
    func fetchWeather(for resort: Resort) async throws -> WeatherInfo {
        let url = try buildURL(path: "/weather/\(resort.id)")
        return try await fetch(url)
    }
    
    func fetchLiftStatus(for resort: Resort) async throws -> [Lift] {
        let url = try buildURL(path: "/lifts/\(resort.id)")
        return try await fetch(url)
    }
    
    func fetchResortInfo(id: String) async throws -> Resort {
        let url = try buildURL(path: "/resorts/\(id)")
        return try await fetch(url)
    }
    
    private func buildURL(path: String) throws -> URL {
        guard let baseURL = try? CoreConfig.getAPIBaseURL(),
              let url = URL(string: path, relativeTo: baseURL) else {
            throw APIError.invalidURL
        }
        return url
    }
    
    private func fetch<T: Decodable>(_ request: URLRequest) async throws -> T {
        let (data, response) = try await session.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse else {
            throw APIError.invalidResponse
        }
        
        switch httpResponse.statusCode {
        case 200...299:
            do {
                return try decoder.decode(T.self, from: data)
            } catch {
                throw APIError.decodingError(error)
            }
        case 401:
            throw APIError.unauthorized
        case 400...499:
            throw APIError.invalidResponse
        case 500...599:
            throw APIError.serverError(httpResponse.statusCode)
        default:
            throw APIError.unknown
        }
    }
    
    private func fetch<T: Decodable>(_ url: URL) async throws -> T {
        var request = URLRequest(url: url)
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        
        if let token = try? CoreConfig.getValue(for: "API_AUTH_TOKEN") {
            request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
        }
        
        return try await fetch(request)
    }
}

struct WeatherInfo: Codable {
    let temperature: Double
    let conditions: String
    let snowDepth: Double
    let windSpeed: Double
    let visibility: Double
} 

### File: App/SkiTrails/Services/ErrorHandler.swift
import Foundation
import CoreLocation
import Sentry
import SkiTrailsCore

/// A service that handles error reporting and user-facing error messages
actor ErrorHandler {
    static let shared = ErrorHandler()
    
    private init() {}
    
    // MARK: - Error Handling
    
    func handle(_ error: Error, context: ErrorContext? = nil) {
        // Log to Sentry
        let event = Event(level: .error)
        event.message = error.localizedDescription
        
        if let context = context {
            event.extra = context.contextData
            event.tags = ["context": context.name]
        }
        
        SentrySDK.capture(event: event)
        
        // Log locally in debug mode
        #if DEBUG
        print("Error: \(error.localizedDescription)")
        if let context = context {
            print("Context: \(context.name)")
            print("Data: \(context.contextData)")
        }
        #endif
    }
    
    func handleUserFacing(_ error: Error, context: ErrorContext? = nil) -> UserFacingError {
        // Log the error
        handle(error, context: context)
        
        // Convert to user-facing error
        switch error {
        case let apiError as APIError:
            return UserFacingError(
                title: "Connection Error",
                message: apiError.localizedDescription,
                recoverySuggestion: apiError.recoverySuggestion
            )
        case let routingError as RoutingError:
            return UserFacingError(
                title: "Navigation Error",
                message: routingError.localizedDescription,
                recoverySuggestion: routingError.recoverySuggestion
            )
        case let locationError as CLError:
            return UserFacingError(
                title: "Location Error",
                message: locationError.localizedDescription,
                recoverySuggestion: "Please check your location permissions and try again."
            )
        default:
            return UserFacingError(
                title: "Error",
                message: error.localizedDescription,
                recoverySuggestion: "Please try again later."
            )
        }
    }
}

// MARK: - Supporting Types

/// Represents an error that can be shown to users
struct UserFacingError: LocalizedError {
    let title: String
    let message: String
    let recoverySuggestion: String?
    
    var errorDescription: String? { message }
}

/// Context information for error reporting
struct ErrorContext {
    let name: String
    let contextData: [String: Any]
    
    static func api(endpoint: String, parameters: [String: Any] = [:]) -> ErrorContext {
        ErrorContext(
            name: "API Error",
            contextData: [
                "endpoint": endpoint,
                "parameters": parameters
            ]
        )
    }
    
    static func navigation(
        start: CLLocationCoordinate2D,
        end: CLLocationCoordinate2D,
        preferences: RoutePreferences
    ) -> ErrorContext {
        ErrorContext(
            name: "Navigation Error",
            contextData: [
                "start": "\(start.latitude),\(start.longitude)",
                "end": "\(end.latitude),\(end.longitude)",
                "preferences": [
                    "avoidCrowds": preferences.avoidCrowds,
                    "preferLessStrenuous": preferences.preferLessStrenuous,
                    "maxWaitTime": preferences.maxWaitTime as Any
                ]
            ]
        )
    }
}

// MARK: - Error Extensions

extension APIError {
    var recoverySuggestion: String? {
        switch self {
        case .invalidURL:
            return "Please check your internet connection and try again."
        case .invalidResponse:
            return "The server returned an invalid response. Please try again later."
        case .networkError:
            return "Please check your internet connection and try again."
        case .decodingError:
            return "There was a problem processing the server response. Please try again later."
        case .serverError:
            return "The server is experiencing issues. Please try again later."
        case .unauthorized:
            return "Please sign in again to continue."
        case .unknown:
            return "Please try again later."
        }
    }
}

extension RoutingError {
    var recoverySuggestion: String? {
        switch self {
        case .graphNotInitialized:
            return "Please wait for the resort data to load and try again."
        case .noRouteFound:
            return "Try selecting different start and end points, or adjust your difficulty preferences."
        case .invalidPath:
            return "The selected route is no longer valid. Please try a different route."
        }
    }
} 

### File: App/SkiTrails/Services/LocationManager.swift
import CoreLocation
import Combine

final class LocationManager: NSObject, ObservableObject {
    private let manager = CLLocationManager()
    
    @Published var authorizationStatus: CLAuthorizationStatus
    @Published var currentLocation: CLLocation?
    
    override init() {
        authorizationStatus = manager.authorizationStatus
        super.init()
        manager.delegate = self
        manager.desiredAccuracy = kCLLocationAccuracyBest
        manager.distanceFilter = 5
        manager.activityType = .fitness
    }
    
    func requestAuthorization() {
        manager.requestWhenInUseAuthorization()
    }
    
    func startUpdatingLocation() {
        manager.startUpdatingLocation()
    }
    
    func stopUpdatingLocation() {
        manager.stopUpdatingLocation()
    }
}

extension LocationManager: CLLocationManagerDelegate {
    func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {
        authorizationStatus = status
    }
    
    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        currentLocation = locations.last
    }
    
    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {
        print("Location manager failed with error: \(error.localizedDescription)")
    }
} 

### File: App/SkiTrails/Services/ResortDataService.swift
import Foundation
import MapboxMaps
import Combine

class ResortDataService: ObservableObject {
    @Published var boundaries: String?
    @Published var runs: String?
    @Published var lifts: String?
    @Published var isLoading = false
    @Published var error: Error?
    
    private let baseURL = "https://api.skiresort.com/v1" // Example API endpoint
    private var cancellables = Set<AnyCancellable>()
    
    func fetchResortData(resortId: String) {
        isLoading = true
        error = nil
        
        // Create API request
        let url = URL(string: "\(baseURL)/resorts/\(resortId)")!
        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        
        // Add API key if required
        if let apiKey = try? ResortConfig.getApiKey() {
            request.setValue(apiKey, forHTTPHeaderField: "X-API-Key")
        }
        
        // Make API request
        URLSession.shared.dataTaskPublisher(for: request)
            .map(\.data)
            .decode(type: ResortResponse.self, decoder: JSONDecoder())
            .receive(on: DispatchQueue.main)
            .sink { completion in
                self.isLoading = false
                if case .failure(let error) = completion {
                    self.error = error
                }
            } receiveValue: { response in
                self.boundaries = response.boundaries
                self.runs = response.runs
                self.lifts = response.lifts
            }
            .store(in: &cancellables)
    }
}

// Response models
struct ResortResponse: Codable {
    let boundaries: String // GeoJSON string
    let runs: String // GeoJSON string
    let lifts: String // GeoJSON string
}

// Configuration
enum ResortConfig {
    enum ConfigError: LocalizedError {
        case missingApiKey
        
        var errorDescription: String? {
            switch self {
            case .missingApiKey:
                return "Resort API key not found. Please set RESORT_API_KEY in your environment or Info.plist."
            }
        }
    }
    
    static func getApiKey() throws -> String {
        // First try environment variable
        if let key = ProcessInfo.processInfo.environment["RESORT_API_KEY"] {
            return key
        }
        
        // Then try Info.plist
        if let key = Bundle.main.object(forInfoDictionaryKey: "ResortApiKey") as? String {
            return key
        }
        
        throw ConfigError.missingApiKey
    }
} 

### File: Tests/SkiTrailsTests/SkiTrailsTests.swift
import XCTest
@testable import SkiTrailsCore

final class SkiTrailsTests: XCTestCase {
    var routingEngine: RoutingEngine!
    var testResort: Resort!
    
    override func setUp() async throws {
        routingEngine = RoutingEngine.shared
        testResort = createTestResort()
        await routingEngine.buildGraph(for: testResort)
    }
    
    func testRouteCalculation() async throws {
        let start = CLLocationCoordinate2D(latitude: 39.6403, longitude: -106.3742)
        let end = CLLocationCoordinate2D(latitude: 39.6500, longitude: -106.3800)
        
        let route = try await routingEngine.findRoute(
            from: start,
            to: end,
            difficulty: .intermediate
        )
        
        XCTAssertFalse(route.segments.isEmpty, "Route should contain segments")
        XCTAssertGreaterThan(route.totalDistance, 0, "Route should have positive distance")
        XCTAssertGreaterThan(route.estimatedTime, 0, "Route should have positive duration")
    }
    
    func testDifficultyFiltering() async throws {
        let start = CLLocationCoordinate2D(latitude: 39.6403, longitude: -106.3742)
        let end = CLLocationCoordinate2D(latitude: 39.6500, longitude: -106.3800)
        
        let beginnerRoute = try await routingEngine.findRoute(
            from: start,
            to: end,
            difficulty: .beginner
        )
        
        XCTAssertEqual(
            beginnerRoute.difficulty,
            .beginner,
            "Route difficulty should not exceed specified maximum"
        )
        
        for segment in beginnerRoute.segments {
            if case .run(let run) = segment.type {
                XCTAssertEqual(
                    run.difficulty,
                    .beginner,
                    "Run difficulty should not exceed beginner level"
                )
            }
        }
    }
    
    func testRoutePreferences() async throws {
        let start = CLLocationCoordinate2D(latitude: 39.6403, longitude: -106.3742)
        let end = CLLocationCoordinate2D(latitude: 39.6500, longitude: -106.3800)
        
        let preferences = RoutePreferences(
            avoidCrowds: true,
            preferLessStrenuous: true,
            maxWaitTime: 300
        )
        
        let route = try await routingEngine.findRoute(
            from: start,
            to: end,
            difficulty: .intermediate,
            preferences: preferences
        )
        
        for segment in route.segments {
            if case .lift(let lift) = segment.type {
                XCTAssertLessThanOrEqual(
                    lift.waitTime ?? 0,
                    preferences.maxWaitTime ?? .infinity,
                    "Lift wait time should not exceed maximum"
                )
            }
        }
    }
    
    // MARK: - Helper Methods
    
    private func createTestResort() -> Resort {
        let lifts = [
            Lift(
                id: UUID(),
                name: "Test Lift 1",
                status: .open,
                startLocation: Location(latitude: 39.6403, longitude: -106.3742, altitude: 2500),
                endLocation: Location(latitude: 39.6450, longitude: -106.3750, altitude: 3000),
                capacity: 4,
                waitTime: 300
            ),
            Lift(
                id: UUID(),
                name: "Test Lift 2",
                status: .open,
                startLocation: Location(latitude: 39.6450, longitude: -106.3750, altitude: 3000),
                endLocation: Location(latitude: 39.6500, longitude: -106.3800, altitude: 3500),
                capacity: 6,
                waitTime: 600
            )
        ]
        
        let runs = [
            Run(
                id: UUID(),
                name: "Easy Street",
                difficulty: .beginner,
                status: .open,
                startLocation: Location(latitude: 39.6450, longitude: -106.3750, altitude: 3000),
                endLocation: Location(latitude: 39.6403, longitude: -106.3742, altitude: 2500),
                length: 1000,
                verticalDrop: 500
            ),
            Run(
                id: UUID(),
                name: "Blue Heaven",
                difficulty: .intermediate,
                status: .open,
                startLocation: Location(latitude: 39.6500, longitude: -106.3800, altitude: 3500),
                endLocation: Location(latitude: 39.6450, longitude: -106.3750, altitude: 3000),
                length: 1500,
                verticalDrop: 500
            )
        ]
        
        return Resort(
            id: UUID(),
            name: "Test Resort",
            lifts: lifts,
            runs: runs
        )
    }
} 

### File: Sources/SkiTrails/ContentView.swift
import SwiftUI
import SkiTrailsCore

struct ContentView: View {
    @EnvironmentObject private var appState: AppState
    
    var body: some View {
        Text("Ski Trails")
            .padding()
            .overlay {
                if appState.isLoading {
                    ProgressView()
                }
            }
    }
}

#Preview {
    ContentView()
        .environmentObject(AppState())
}

### File: Sources/SkiTrails/SkiTrailsApp.swift
import SwiftUI
import SkiTrailsCore

@main
struct SkiTrailsApp: App {
    @StateObject private var appState = AppState()
    
    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(appState)
        }
    }
} 

### File: Sources/SkiTrails/Images.xcassets/Contents.json
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
} 

### File: Sources/SkiTrails/Images.xcassets/AppIcon.appiconset/Contents.json
{
  "images" : [
    {
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "20x20"
    },
    {
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "20x20"
    },
    {
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "29x29"
    },
    {
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "29x29"
    },
    {
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "40x40"
    },
    {
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "40x40"
    },
    {
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "60x60"
    },
    {
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "60x60"
    },
    {
      "idiom" : "ios-marketing",
      "scale" : "1x",
      "size" : "1024x1024"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
} 

### File: Sources/SkiTrailsCore/SkiTrailsCore.swift
@_exported import Foundation
@_exported import SwiftUI

// No type aliases - use CoreState and CoreConfig directly 

### File: Sources/SkiTrailsCore/ViewModels/MapViewModel.swift
import SwiftUI
import CoreLocation

public class MapViewModel: ObservableObject {
    @Published public var selectedFeature: MapFeature?
    
    public let defaultCenter = CLLocationCoordinate2D(latitude: 39.6403, longitude: -106.3742) // Vail, CO
    public let defaultZoom = 14.0
    public let defaultPitch = 45.0
    public let defaultBearing = 0.0
    
    public init() {}
} 

### File: Sources/SkiTrailsCore/Configuration/Configuration.swift
import Foundation

public struct Configuration {
    public let apiBaseURL: URL
    public let apiKey: String
    
    public init() throws {
        self.apiBaseURL = try CoreConfig.getAPIBaseURL()
        self.apiKey = try CoreConfig.getValue(for: "API_AUTH_TOKEN")
    }
    
    public static func `default`() throws -> Configuration {
        try Configuration()
    }
}

extension Configuration {
    public enum Error: Swift.Error, LocalizedError {
        case invalidURL
        case missingAPIKey
        
        public var errorDescription: String? {
            switch self {
            case .invalidURL:
                return "Invalid API base URL format"
            case .missingAPIKey:
                return "Missing API authentication key"
            }
        }
    }
} 

### File: Sources/SkiTrailsCore/Configuration/CoreConfig.swift
import Foundation
import SwiftUI

// MARK: - Core Configuration
public enum CoreConfig {
    public enum Error: Swift.Error, LocalizedError {
        case fileNotFound(String)
        case invalidFormat
        case missingKey(String)
        
        public var errorDescription: String? {
            switch self {
            case .fileNotFound(let path):
                return "Environment file not found at: \(path)"
            case .invalidFormat:
                return "Invalid environment file format"
            case .missingKey(let key):
                return "Missing required environment variable: \(key)"
            }
        }
    }
    
    private static var envVariables: [String: String]?
    
    private static func loadEnvironmentVariables() throws -> [String: String] {
        if let existing = envVariables {
            return existing
        }
        
        guard let path = Bundle.main.path(forResource: ".env", ofType: nil) else {
            throw Error.fileNotFound(".env")
        }
        
        let content = try String(contentsOfFile: path, encoding: .utf8)
        var variables: [String: String] = [:]
        
        content.components(separatedBy: .newlines).forEach { line in
            let parts = line.split(separator: "=", maxSplits: 1)
            if parts.count == 2 {
                let key = String(parts[0]).trimmingCharacters(in: .whitespaces)
                let value = String(parts[1]).trimmingCharacters(in: .whitespaces)
                if !key.hasPrefix("#") {
                    variables[key] = value
                }
            }
        }
        
        envVariables = variables
        return variables
    }
    
    public static func getValue(for key: String) throws -> String {
        let variables = try loadEnvironmentVariables()
        guard let value = variables[key] else {
            throw Error.missingKey(key)
        }
        return value
    }
    
    public static func getDSN() throws -> String {
        try getValue(for: "SENTRY_DSN")
    }
    
    public static func getMapboxAccessToken() throws -> String {
        try getValue(for: "MAPBOX_ACCESS_TOKEN")
    }
    
    public static func getWeatherAPIKey() throws -> String {
        try getValue(for: "WEATHER_UNLOCKED_API_KEY")
    }
    
    public static func getWeatherAppID() throws -> String {
        try getValue(for: "WEATHER_UNLOCKED_APP_ID")
    }
    
    public static func getLiftieAPIBaseURL() throws -> String {
        try getValue(for: "LIFTIE_API_BASE_URL")
    }
    
    public static func getLiftieResortList() throws -> [String] {
        let list = try getValue(for: "LIFTIE_RESORT_LIST")
        return list.split(separator: ",").map(String.init)
    }
    
    public static func getAPIBaseURL() throws -> URL {
        let urlString = try getValue(for: "API_BASE_URL")
        guard let url = URL(string: urlString) else {
            throw Error.invalidFormat
        }
        return url
    }
}

// MARK: - Core State Management
public protocol CoreStateManaging: ObservableObject {
    var selectedResort: Resort? { get }
    var isLoading: Bool { get }
    var error: Error? { get }
    
    func selectResort(_ resort: Resort)
    func setError(_ error: Error)
    func setLoading(_ loading: Bool)
}

public final class CoreState: CoreStateManaging {
    @Published public private(set) var selectedResort: Resort?
    @Published public private(set) var isLoading = false
    @Published public private(set) var error: Error?
    
    public init() {}
    
    public func selectResort(_ resort: Resort) {
        selectedResort = resort
    }
    
    public func setError(_ error: Error) {
        self.error = error
    }
    
    public func setLoading(_ loading: Bool) {
        isLoading = loading
    }
} 

### File: Sources/SkiTrailsCore/Configuration/MapConfig.swift
import Foundation

public enum MapConfig {
    public enum Error: Swift.Error, LocalizedError {
        case missingMapboxToken
        
        public var errorDescription: String? {
            switch self {
            case .missingMapboxToken:
                return "Missing Mapbox access token"
            }
        }
    }
    
    public static func getMapboxAccessToken() throws -> String {
        try CoreConfig.getMapboxAccessToken()
    }
} 

### File: Sources/SkiTrailsCore/Models/AppState.swift
import Foundation
import SwiftUI

public class AppState: ObservableObject {
    @Published public var isLoading: Bool = false
    @Published public var selectedTrail: String? = nil
    @Published public var navigationActive: Bool = false
    @Published public var error: Error?
    
    public let configuration: Configuration?
    
    public init() {
        do {
            self.configuration = try Configuration.default()
        } catch {
            self.configuration = nil
            self.error = error
        }
    }
    
    public init(configuration: Configuration) {
        self.configuration = configuration
    }
} 

### File: Sources/SkiTrailsCore/Models/HeavenlyData.swift
import Foundation

public enum HeavenlyData {
    public static let runs = """
    {
      "type": "FeatureCollection",
      "features": [
        {
          "type": "Feature",
          "properties": {
            "name": "Orion",
            "difficulty": "blue",
            "status": "open"
          },
          "geometry": {
            "type": "Polygon",
            "coordinates": [[
              [-119.939, 38.935],
              [-119.938, 38.934],
              [-119.937, 38.933],
              [-119.938, 38.932],
              [-119.939, 38.935]
            ]]
          }
        },
        {
          "type": "Feature",
          "properties": {
            "name": "Comet",
            "difficulty": "black",
            "status": "open"
          },
          "geometry": {
            "type": "Polygon",
            "coordinates": [[
              [-119.940, 38.936],
              [-119.939, 38.935],
              [-119.938, 38.934],
              [-119.939, 38.933],
              [-119.940, 38.936]
            ]]
          }
        },
        {
          "type": "Feature",
          "properties": {
            "name": "Big Dipper",
            "difficulty": "blue",
            "status": "open"
          },
          "geometry": {
            "type": "Polygon",
            "coordinates": [[
              [-119.941, 38.937],
              [-119.940, 38.936],
              [-119.939, 38.935],
              [-119.940, 38.934],
              [-119.941, 38.937]
            ]]
          }
        }
      ]
    }
    """
    
    public static let lifts = """
    {
      "type": "FeatureCollection",
      "features": [
        {
          "type": "Feature",
          "properties": {
            "name": "Heavenly Gondola",
            "type": "gondola",
            "status": "open"
          },
          "geometry": {
            "type": "LineString",
            "coordinates": [
              [-119.939, 38.935],
              [-119.938, 38.934],
              [-119.937, 38.933]
            ]
          }
        },
        {
          "type": "Feature",
          "properties": {
            "name": "Comet Express",
            "type": "chairlift",
            "status": "open"
          },
          "geometry": {
            "type": "LineString",
            "coordinates": [
              [-119.940, 38.936],
              [-119.939, 38.935],
              [-119.938, 38.934]
            ]
          }
        },
        {
          "type": "Feature",
          "properties": {
            "name": "Dipper Express",
            "type": "chairlift",
            "status": "open"
          },
          "geometry": {
            "type": "LineString",
            "coordinates": [
              [-119.941, 38.937],
              [-119.940, 38.936],
              [-119.939, 38.935]
            ]
          }
        }
      ]
    }
    """
    
    public static let boundaries = """
    {
      "type": "FeatureCollection",
      "features": [
        {
          "type": "Feature",
          "properties": {
            "name": "Heavenly Resort Boundary"
          },
          "geometry": {
            "type": "Polygon",
            "coordinates": [[
              [-119.942, 38.938],
              [-119.936, 38.938],
              [-119.936, 38.932],
              [-119.942, 38.932],
              [-119.942, 38.938]
            ]]
          }
        }
      ]
    }
    """
} 

### File: Sources/SkiTrailsCore/Models/MapFeature.swift
import Foundation

public enum MapFeature {
    case run(Run)
    case lift(Lift)
    case point(name: String, latitude: Double, longitude: Double)
    
    public var name: String {
        switch self {
        case .run(let run):
            return run.name
        case .lift(let lift):
            return lift.name
        case .point(let name, _, _):
            return name
        }
    }
    
    public var coordinates: (latitude: Double, longitude: Double) {
        switch self {
        case .run(let run):
            return (run.startLocation.latitude, run.startLocation.longitude)
        case .lift(let lift):
            return (lift.startLocation.latitude, lift.startLocation.longitude)
        case .point(_, let latitude, let longitude):
            return (latitude, longitude)
        }
    }
} 

### File: Sources/SkiTrailsCore/Models/Resort.swift
import Foundation

public struct Resort: Identifiable {
    public let id: UUID
    public let name: String
    public let lifts: [Lift]
    public let runs: [Run]
    public var weather: Weather?
    
    public init(id: UUID = UUID(), name: String, lifts: [Lift], runs: [Run], weather: Weather? = nil) {
        self.id = id
        self.name = name
        self.lifts = lifts
        self.runs = runs
        self.weather = weather
    }
}

public struct Lift: Identifiable {
    public let id: UUID
    public let name: String
    public let status: Status
    public let startLocation: Location
    public let endLocation: Location
    public let capacity: Int
    public let waitTime: TimeInterval?
    
    public enum Status: String {
        case open, closed, onHold, maintenance
    }
}

public struct Run: Identifiable {
    public let id: UUID
    public let name: String
    public let difficulty: Difficulty
    public let status: Status
    public let startLocation: Location
    public let endLocation: Location
    public let length: Double
    public let verticalDrop: Double
    
    public enum Difficulty: String, CaseIterable {
        case beginner, intermediate, advanced, expert
    }
    
    public enum Status: String {
        case open, closed, grooming
    }
}

public struct Location: Equatable, Hashable {
    public let latitude: Double
    public let longitude: Double
    public let altitude: Double
    
    public init(latitude: Double, longitude: Double, altitude: Double) {
        self.latitude = latitude
        self.longitude = longitude
        self.altitude = altitude
    }
}

public struct Weather {
    public let temperature: Double
    public let conditions: String
    public let snowDepth: Double
    public let windSpeed: Double
    public let visibility: Double
    
    public init(temperature: Double, conditions: String, snowDepth: Double, windSpeed: Double, visibility: Double) {
        self.temperature = temperature
        self.conditions = conditions
        self.snowDepth = snowDepth
        self.windSpeed = windSpeed
        self.visibility = visibility
    }
} 

### File: Sources/SkiTrailsCore/Models/Status.swift
import SwiftUI

public enum Status: String, Codable {
    case open
    case closed
    case hold
    case scheduled
    case grooming
    
    public var color: Color {
        switch self {
        case .open: return .green
        case .closed: return .red
        case .hold: return .orange
        case .scheduled: return .blue
        case .grooming: return .purple
        }
    }
} 

### File: Sources/SkiTrailsCore/Routing/RoutingEngine.swift
import Foundation
import CoreLocation

public actor RoutingEngine {
    public static let shared = RoutingEngine()
    private var resortGraph: ResortGraph?
    
    private init() {}
    
    // MARK: - Graph Management
    
    public func buildGraph(for resort: Resort) {
        let nodes = buildNodes(from: resort)
        let edges = buildEdges(from: resort)
        resortGraph = ResortGraph(nodes: nodes, edges: edges)
    }
    
    public func findRoute(
        from start: CLLocationCoordinate2D,
        to end: CLLocationCoordinate2D,
        difficulty: SkiDifficulty = .intermediate,
        preferences: RoutePreferences = RoutePreferences()
    ) async throws -> Route {
        guard let graph = resortGraph else {
            throw RoutingError.graphNotInitialized
        }
        
        let startNode = findNearestNode(to: start, in: graph)
        let endNode = findNearestNode(to: end, in: graph)
        
        let path = try findPath(from: startNode, to: endNode, in: graph, maxDifficulty: difficulty)
        return try buildRoute(from: path, in: graph)
    }
    
    // MARK: - Private Methods
    
    private func buildNodes(from resort: Resort) -> [String: Node] {
        var nodes: [String: Node] = [:]
        
        // Add lift nodes
        for lift in resort.lifts {
            nodes[lift.id.uuidString] = Node(
                id: lift.id.uuidString,
                coordinate: CLLocationCoordinate2D(latitude: lift.startLocation.latitude, longitude: lift.startLocation.longitude),
                elevation: lift.startLocation.elevation
            )
        }
        
        // Add run nodes
        for run in resort.runs {
            // Add top node for the run
            let topNodeId = "\(run.id.uuidString)_top"
            nodes[topNodeId] = Node(
                id: topNodeId,
                coordinate: CLLocationCoordinate2D(latitude: run.startLocation.latitude, longitude: run.startLocation.longitude),
                elevation: run.startLocation.elevation
            )
            
            // Add bottom node for the run
            let bottomNodeId = "\(run.id.uuidString)_bottom"
            nodes[bottomNodeId] = Node(
                id: bottomNodeId,
                coordinate: CLLocationCoordinate2D(latitude: run.endLocation.latitude, longitude: run.endLocation.longitude),
                elevation: run.endLocation.elevation
            )
        }
        
        return nodes
    }
    
    private func buildEdges(from resort: Resort) -> [Edge] {
        var edges: [Edge] = []
        
        // For each lift, connect to nearby run tops (only if both lift and run are open)
        for lift in resort.lifts {
            if lift.status != .open {
                continue
            }
            
            for run in resort.runs {
                if run.status != .open {
                    continue
                }
                
                // Connect lift to run top if they're close enough
                let liftLocation = CLLocation(
                    latitude: lift.startLocation.latitude,
                    longitude: lift.startLocation.longitude
                )
                let runTopLocation = CLLocation(
                    latitude: run.startLocation.latitude,
                    longitude: run.startLocation.longitude
                )
                
                if liftLocation.distance(from: runTopLocation) < 100 { // 100m threshold
                    edges.append(Edge(
                        from: lift.id.uuidString,
                        to: "\(run.id.uuidString)_top",
                        type: .run(difficulty: run.difficulty),
                        distance: liftLocation.distance(from: runTopLocation)
                    ))
                }
            }
        }
        
        // For each run, connect its top to its bottom (only if run is open)
        for run in resort.runs {
            if run.status != .open {
                continue
            }
            
            let topNodeId = "\(run.id.uuidString)_top"
            let bottomNodeId = "\(run.id.uuidString)_bottom"
            
            edges.append(Edge(
                from: topNodeId,
                to: bottomNodeId,
                type: .run(difficulty: run.difficulty),
                distance: run.length
            ))
        }
        
        // For each run's bottom, connect to nearby lift bases (only if both run and lift are open)
        for run in resort.runs {
            if run.status != .open {
                continue
            }
            
            let runBottomLocation = CLLocation(
                latitude: run.endLocation.latitude,
                longitude: run.endLocation.longitude
            )
            
            for lift in resort.lifts {
                if lift.status != .open {
                    continue
                }
                
                let liftBaseLocation = CLLocation(
                    latitude: lift.startLocation.latitude,
                    longitude: lift.startLocation.longitude
                )
                
                if runBottomLocation.distance(from: liftBaseLocation) < 100 { // 100m threshold
                    edges.append(Edge(
                        from: "\(run.id.uuidString)_bottom",
                        to: lift.id.uuidString,
                        type: .lift,
                        distance: runBottomLocation.distance(from: liftBaseLocation)
                    ))
                }
            }
        }
        
        return edges
    }
    
    private func findNearestNode(to coordinate: CLLocationCoordinate2D, in graph: ResortGraph) -> Node {
        let location = CLLocation(latitude: coordinate.latitude, longitude: coordinate.longitude)
        
        return graph.nodes.values.min { a, b in
            let aLocation = CLLocation(
                latitude: a.coordinate.latitude,
                longitude: a.coordinate.longitude
            )
            let bLocation = CLLocation(
                latitude: b.coordinate.latitude,
                longitude: b.coordinate.longitude
            )
            
            return location.distance(from: aLocation) < location.distance(from: bLocation)
        }!
    }
    
    private func findPath(from start: Node, to end: Node, in graph: ResortGraph, maxDifficulty: SkiDifficulty) throws -> [String] {
        var openSet = Set<String>([start.id])
        var closedSet = Set<String>()
        
        var cameFrom: [String: String] = [:]
        var gScore: [String: Double] = [start.id: 0]
        var fScore: [String: Double] = [start.id: heuristic(from: start, to: end)]
        
        while !openSet.isEmpty {
            let current = openSet.min { a, b in
                (fScore[a] ?? .infinity) < (fScore[b] ?? .infinity)
            }!
            
            if current == end.id {
                return reconstructPath(cameFrom: cameFrom, current: current)
            }
            
            openSet.remove(current)
            closedSet.insert(current)
            
            let edges = graph.edges.filter { $0.from == current }
            for edge in edges {
                guard !closedSet.contains(edge.to),
                      let node = graph.nodes[edge.to] else {
                    continue
                }
                
                // Skip if difficulty is too high
                if case .run(let run) = node.type,
                   !isRunAllowed(run, maxDifficulty: maxDifficulty) {
                    continue
                }
                
                let tentativeGScore = (gScore[current] ?? .infinity) + edge.distance
                
                if !openSet.contains(edge.to) {
                    openSet.insert(edge.to)
                } else if tentativeGScore >= (gScore[edge.to] ?? .infinity) {
                    continue
                }
                
                cameFrom[edge.to] = current
                gScore[edge.to] = tentativeGScore
                fScore[edge.to] = tentativeGScore + heuristic(from: node, to: end)
            }
        }
        
        throw RoutingError.noRouteFound
    }
    
    private func reconstructPath(cameFrom: [String: String], current: String) -> [String] {
        var path = [current]
        var currentNode = current
        
        while let previous = cameFrom[currentNode] {
            path.insert(previous, at: 0)
            currentNode = previous
        }
        
        return path
    }
    
    private func buildRoute(from path: [String], in graph: ResortGraph) throws -> Route {
        var segments: [Route.Segment] = []
        var totalDistance: Double = 0
        var maxDifficulty: SkiDifficulty = .beginner
        
        for i in 0..<(path.count - 1) {
            let fromId = path[i]
            let toId = path[i + 1]
            
            guard let fromNode = graph.nodes[fromId],
                  let toNode = graph.nodes[toId],
                  let edge = graph.edges.first(where: { $0.from == fromId && $0.to == toId }) else {
                throw RoutingError.invalidPath
            }
            
            let segment = try buildSegment(
                from: fromNode,
                to: toNode,
                edge: edge
            )
            
            segments.append(segment)
            totalDistance += segment.distance
            
            if case .run(let run) = segment.type {
                maxDifficulty = max(maxDifficulty, run.difficulty)
            }
        }
        
        return Route(
            segments: segments,
            totalDistance: totalDistance,
            estimatedTime: calculateEstimatedTime(for: segments),
            difficulty: maxDifficulty
        )
    }
    
    private func heuristic(from: Node, to: Node) -> Double {
        let fromLocation = CLLocation(
            latitude: from.coordinate.latitude,
            longitude: from.coordinate.longitude
        )
        let toLocation = CLLocation(
            latitude: to.coordinate.latitude,
            longitude: to.coordinate.longitude
        )
        
        return fromLocation.distance(from: toLocation)
    }
    
    private func isRunAllowed(_ run: Run, maxDifficulty: SkiDifficulty) -> Bool {
        switch (run.difficulty, maxDifficulty) {
        case (.beginner, _):
            return true
        case (.intermediate, .intermediate), (.intermediate, .advanced), (.intermediate, .expert):
            return true
        case (.advanced, .advanced), (.advanced, .expert):
            return true
        case (.expert, .expert):
            return true
        default:
            return false
        }
    }
    
    private func calculateEstimatedTime(for segments: [Route.Segment]) -> TimeInterval {
        segments.reduce(0) { total, segment in
            switch segment.type {
            case .run:
                // Assume average speed of 20 km/h on runs
                return total + (segment.distance / 5.56) // 5.56 m/s = 20 km/h
            case .lift:
                // Assume average lift speed of 5 m/s
                return total + (segment.distance / 5.0)
            case .connection:
                // Assume walking speed of 1.4 m/s
                return total + (segment.distance / 1.4)
            }
        }
    }
    
    private func buildSegment(
        from: Node,
        to: Node,
        edge: Edge
    ) throws -> Route.Segment {
        let type: Route.Segment.SegmentType
        
        switch (from.type, to.type) {
        case (.lift(let lift), .run):
            type = .lift(lift)
        case (.run(let run), _):
            type = .run(run)
        default:
            type = .connection
        }
        
        return Route.Segment(
            type: type,
            path: [
                Route.Segment.Location(
                    latitude: from.coordinate.latitude,
                    longitude: from.coordinate.longitude,
                    altitude: from.elevation
                ),
                Route.Segment.Location(
                    latitude: to.coordinate.latitude,
                    longitude: to.coordinate.longitude,
                    altitude: to.elevation
                )
            ],
            distance: edge.distance
        )
    }
}

// MARK: - Supporting Types

public struct ResortGraph {
    let nodes: [String: Node]
    let edges: [Edge]
}

public struct Node {
    let id: String
    let coordinate: CLLocationCoordinate2D
    let elevation: Double
}

public struct Edge {
    let from: String
    let to: String
    let type: EdgeType
    let distance: Double
    
    enum EdgeType {
        case run(difficulty: SkiDifficulty)
        case lift
        case connection
    }
}

public struct RoutePreferences {
    public let avoidCrowds: Bool
    public let preferLessStrenuous: Bool
    public let maxWaitTime: TimeInterval?
    
    public init(avoidCrowds: Bool = false, preferLessStrenuous: Bool = false, maxWaitTime: TimeInterval? = nil) {
        self.avoidCrowds = avoidCrowds
        self.preferLessStrenuous = preferLessStrenuous
        self.maxWaitTime = maxWaitTime
    }
}

public enum RoutingError: Error {
    case graphNotInitialized
    case noRouteFound
    case invalidPath
} 

### File: Sources/SkiTrailsCore/Routing/RoutingTypes.swift
import Foundation
import CoreLocation

public enum SkiDifficulty: String, CaseIterable, Comparable {
    case beginner, intermediate, advanced, expert
    
    public static func < (lhs: SkiDifficulty, rhs: SkiDifficulty) -> Bool {
        let order: [SkiDifficulty] = [.beginner, .intermediate, .advanced, .expert]
        guard let lhsIndex = order.firstIndex(of: lhs),
              let rhsIndex = order.firstIndex(of: rhs) else {
            return false
        }
        return lhsIndex < rhsIndex
    }
    
    public var color: String {
        switch self {
        case .beginner: return "green"
        case .intermediate: return "blue"
        case .advanced: return "black"
        case .expert: return "doubleBlack"
        }
    }
}

public struct Route {
    public let segments: [Segment]
    public let totalDistance: Double
    public let estimatedTime: TimeInterval
    public let difficulty: SkiDifficulty
    
    public struct Segment {
        public let type: SegmentType
        public let path: [Location]
        public let distance: Double
        
        public enum SegmentType {
            case run(Run)
            case lift(Lift)
            case connection
        }
        
        public struct Location {
            public let latitude: Double
            public let longitude: Double
            public let altitude: Double
        }
    }
} 

### File: .swiftpm/xcode/package.xcworkspace/contents.xcworkspacedata
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
</Workspace>


### File: .swiftpm/xcode/xcuserdata/bsteinher.xcuserdatad/xcschemes/xcschememanagement.plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>SchemeUserState</key>
	<dict>
		<key>SkiTrailsCore.xcscheme_^#shared#^_</key>
		<dict>
			<key>orderHint</key>
			<integer>1</integer>
		</dict>
	</dict>
</dict>
</plist>
