# File Tree - Generated on 2025-01-14 18:10:44

├── LICENSE
├── Package.resolved
├── Package.swift
├── README.md
├── combined_files.txt
├── envmirror.md
├── iOS-transition-todo.md
├── project.yml
├── App
│   └── SkiTrails
│       ├── Info.plist
│       ├── SkiTrailsApp.swift
│       ├── App
│       ├── Bundle.docc
│       │   ├── Configuration.plist
│       │   └── Info.plist
│       ├── Extensions
│       │   └── SkiDifficulty+Color.swift
│       ├── Images.xcassets
│       │   ├── Contents.json
│       │   └── AppIcon.appiconset
│       │       └── Contents.json
│       ├── Models
│       │   ├── AppState.swift
│       │   ├── HeavenlyData.swift
│       │   ├── Status.swift
│       │   └── TrailDifficulty.swift
│       ├── Resources
│       ├── Services
│       │   ├── APIClient.swift
│       │   ├── ErrorHandler.swift
│       │   ├── LocationManager.swift
│       │   └── ResortDataService.swift
│       ├── Utils
│       │   ├── EnvConfig.swift
│       │   └── MapConfig.swift
│       ├── ViewModels
│       │   ├── ContentViewModel.swift
│       │   ├── MapViewModel.swift
│       │   ├── NavigationViewModel.swift
│       │   └── ResortViewModel.swift
│       └── Views
│           ├── ActiveNavigationView.swift
│           ├── ErrorAlertView.swift
│           ├── MapSelectionView.swift
│           ├── MapView.swift
│           ├── MapboxMapView.swift
│           ├── RouteDetailView.swift
│           ├── RouteOverlayView.swift
│           ├── RouteSelectionView.swift
│           ├── Views.swift
│           └── Components
├── SkiTrailsCore
│   ├── Package.swift
│   └── Sources
│       └── SkiTrailsCore
│           ├── Configuration
│           │   ├── Configuration.swift
│           │   ├── CoreConfig.swift
│           │   └── MapConfig.swift
│           ├── Models
│           │   ├── AppState.swift
│           │   ├── HeavenlyData.swift
│           │   ├── MapFeature.swift
│           │   ├── Resort.swift
│           │   └── Status.swift
│           ├── Routing
│           │   ├── RoutingEngine.swift
│           │   └── RoutingTypes.swift
│           ├── Services
│           │   └── APIClient.swift
│           └── ViewModels
│               └── MapViewModel.swift
├── Sources
│   ├── SkiTrails
│   │   ├── ContentView.swift
│   │   └── Images.xcassets
│   │       ├── Contents.json
│   │       └── AppIcon.appiconset
│   │           └── Contents.json
│   └── SkiTrailsCore
│       ├── SkiTrailsCore.swift
│       ├── Configuration
│       │   ├── Configuration.swift
│       │   ├── CoreConfig.swift
│       │   └── MapConfig.swift
│       ├── Models
│       │   ├── AppState.swift
│       │   ├── HeavenlyData.swift
│       │   ├── MapFeature.swift
│       │   ├── Resort.swift
│       │   └── Status.swift
│       ├── Routing
│       │   ├── RoutingEngine.swift
│       │   └── RoutingTypes.swift
│       ├── Services
│       │   └── APIClient.swift
│       └── ViewModels
│           └── MapViewModel.swift
└── Tests
    └── SkiTrailsTests
        └── SkiTrailsTests.swift

# Combined Files Content


### File: LICENSE
MIT License

Copyright (c) 2024 Turn-By-Turn Ski Trails

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE. 

### File: Package.resolved
{
  "pins" : [
    {
      "identity" : "mapbox-common-ios",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/mapbox/mapbox-common-ios.git",
      "state" : {
        "revision" : "ce35687685331b1690149637d25ddc47d88146de",
        "version" : "23.11.2"
      }
    },
    {
      "identity" : "mapbox-core-maps-ios",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/mapbox/mapbox-core-maps-ios.git",
      "state" : {
        "revision" : "95bb164a4ca016cb6fce3cdfb13c4902bf8b8c18",
        "version" : "10.19.2"
      }
    },
    {
      "identity" : "mapbox-maps-ios",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/mapbox/mapbox-maps-ios.git",
      "state" : {
        "revision" : "0af0d49fe085923af5dcd00714ec0c6c129a44f3",
        "version" : "10.19.1"
      }
    },
    {
      "identity" : "turf-swift",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/mapbox/turf-swift.git",
      "state" : {
        "revision" : "213050191cfcb3d5aa76e1fa90c6ff1e182a42ca",
        "version" : "2.8.0"
      }
    }
  ],
  "version" : 2
}


### File: Package.swift
// swift-tools-version:5.9
import PackageDescription

let package = Package(
    name: "SkiTrails",
    platforms: [
        .iOS(.v17),
        .macOS(.v14)
    ],
    products: [
        .library(
            name: "SkiTrailsCore",
            targets: ["SkiTrailsCore"]
        )
    ],
    dependencies: [
        .package(url: "https://github.com/mapbox/mapbox-maps-ios.git", "10.16.0"..<"11.0.0"),
        .package(url: "https://github.com/mapbox/turf-swift.git", exact: "2.8.0")
    ],
    targets: [
        .target(
            name: "SkiTrailsCore",
            dependencies: [
                .product(name: "MapboxMaps", package: "mapbox-maps-ios"),
                .product(name: "Turf", package: "turf-swift")
            ],
            path: "Sources/SkiTrailsCore"
        ),
        .executableTarget(
            name: "SkiTrails",
            dependencies: [
                "SkiTrailsCore",
                .product(name: "MapboxMaps", package: "mapbox-maps-ios"),
                .product(name: "Turf", package: "turf-swift")
            ],
            path: "App/SkiTrails"
        ),
        .testTarget(
            name: "SkiTrailsCoreTests",
            dependencies: ["SkiTrailsCore"]
        )
    ]
) 

### File: README.md
# Turn-By-Turn Ski Trails

A 3D ski resort mapping application built with SwiftUI that provides interactive trail maps, turn-by-turn navigation, and real-time resort information.

## Features

- Interactive 3D map of ski resorts with lifts and runs
- Turn-by-turn navigation between points
- Filtering for runs by difficulty level
- Real-time lift and run status updates
- Weather and snow condition information

## Requirements

- iOS 17.0+
- Xcode 15.0+
- Swift 5.9+

## Installation

1. Clone the repository
2. Set up environment variables (see Environment Configuration below)
3. Open `SkiTrails.xcodeproj` in Xcode
4. Build and run

## Environment Configuration

The app requires several environment variables to be set. These can be configured in two ways:

1. Using Xcode scheme environment variables (recommended for development)
2. Using launch arguments when running the app (recommended for CI/CD)

Required environment variables:
```
MAPBOX_ACCESS_TOKEN=your_mapbox_token
WEATHER_UNLOCKED_API_KEY=your_weather_api_key
WEATHER_UNLOCKED_APP_ID=your_weather_app_id
SKI_API_KEY=your_ski_api_key
SENTRY_DSN=your_sentry_dsn
```

See `.env.example` for a complete list of available configuration options.

## APIs Used

- Mapbox for 3D terrain visualization
- Weather Unlocked for snow and weather data
- Liftie API for real-time lift status
- Custom routing engine for navigation

## Architecture

The app follows a clean architecture pattern with:

- SwiftUI views for the UI layer
- MVVM pattern for presentation logic
- Domain layer for business logic
- Data layer for API integration

The project is structured into two main targets:
- `SkiTrails`: The main iOS app
- `SkiTrailsCore`: A Swift Package containing core business logic and models

## License

This project is licensed under the MIT License - see the LICENSE file for details. 

### File: combined_files.txt
# File Tree - Generated on 2025-01-14 18:10:44

├── LICENSE
├── Package.resolved
├── Package.swift
├── README.md
├── combined_files.txt
├── envmirror.md
├── iOS-transition-todo.md
├── project.yml
├── App
│   └── SkiTrails
│       ├── Info.plist
│       ├── SkiTrailsApp.swift
│       ├── App
│       ├── Bundle.docc
│       │   ├── Configuration.plist
│       │   └── Info.plist
│       ├── Extensions
│       │   └── SkiDifficulty+Color.swift
│       ├── Images.xcassets
│       │   ├── Contents.json
│       │   └── AppIcon.appiconset
│       │       └── Contents.json
│       ├── Models
│       │   ├── AppState.swift
│       │   ├── HeavenlyData.swift
│       │   ├── Status.swift
│       │   └── TrailDifficulty.swift
│       ├── Resources
│       ├── Services
│       │   ├── APIClient.swift
│       │   ├── ErrorHandler.swift
│       │   ├── LocationManager.swift
│       │   └── ResortDataService.swift
│       ├── Utils
│       │   ├── EnvConfig.swift
│       │   └── MapConfig.swift
│       ├── ViewModels
│       │   ├── ContentViewModel.swift
│       │   ├── MapViewModel.swift
│       │   ├── NavigationViewModel.swift
│       │   └── ResortViewModel.swift
│       └── Views
│           ├── ActiveNavigationView.swift
│           ├── ErrorAlertView.swift
│           ├── MapSelectionView.swift
│           ├── MapView.swift
│           ├── MapboxMapView.swift
│           ├── RouteDetailView.swift
│           ├── RouteOverlayView.swift
│           ├── RouteSelectionView.swift
│           ├── Views.swift
│           └── Components
├── SkiTrailsCore
│   ├── Package.swift
│   └── Sources
│       └── SkiTrailsCore
│           ├── Configuration
│           │   ├── Configuration.swift
│           │   ├── CoreConfig.swift
│           │   └── MapConfig.swift
│           ├── Models
│           │   ├── AppState.swift
│           │   ├── HeavenlyData.swift
│           │   ├── MapFeature.swift
│           │   ├── Resort.swift
│           │   └── Status.swift
│           ├── Routing
│           │   ├── RoutingEngine.swift
│           │   └── RoutingTypes.swift
│           ├── Services
│           │   └── APIClient.swift
│           └── ViewModels
│               └── MapViewModel.swift
├── Sources
│   ├── SkiTrails
│   │   ├── ContentView.swift
│   │   └── Images.xcassets
│   │       ├── Contents.json
│   │       └── AppIcon.appiconset
│   │           └── Contents.json
│   └── SkiTrailsCore
│       ├── SkiTrailsCore.swift
│       ├── Configuration
│       │   ├── Configuration.swift
│       │   ├── CoreConfig.swift
│       │   └── MapConfig.swift
│       ├── Models
│       │   ├── AppState.swift
│       │   ├── HeavenlyData.swift
│       │   ├── MapFeature.swift
│       │   ├── Resort.swift
│       │   └── Status.swift
│       ├── Routing
│       │   ├── RoutingEngine.swift
│       │   └── RoutingTypes.swift
│       ├── Services
│       │   └── APIClient.swift
│       └── ViewModels
│           └── MapViewModel.swift
└── Tests
    └── SkiTrailsTests
        └── SkiTrailsTests.swift

# Combined Files Content


### File: LICENSE
MIT License

Copyright (c) 2024 Turn-By-Turn Ski Trails

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE. 

### File: Package.resolved
{
  "pins" : [
    {
      "identity" : "mapbox-common-ios",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/mapbox/mapbox-common-ios.git",
      "state" : {
        "revision" : "ce35687685331b1690149637d25ddc47d88146de",
        "version" : "23.11.2"
      }
    },
    {
      "identity" : "mapbox-core-maps-ios",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/mapbox/mapbox-core-maps-ios.git",
      "state" : {
        "revision" : "95bb164a4ca016cb6fce3cdfb13c4902bf8b8c18",
        "version" : "10.19.2"
      }
    },
    {
      "identity" : "mapbox-maps-ios",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/mapbox/mapbox-maps-ios.git",
      "state" : {
        "revision" : "0af0d49fe085923af5dcd00714ec0c6c129a44f3",
        "version" : "10.19.1"
      }
    },
    {
      "identity" : "turf-swift",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/mapbox/turf-swift.git",
      "state" : {
        "revision" : "213050191cfcb3d5aa76e1fa90c6ff1e182a42ca",
        "version" : "2.8.0"
      }
    }
  ],
  "version" : 2
}


### File: Package.swift
// swift-tools-version:5.9
import PackageDescription

let package = Package(
    name: "SkiTrails",
    platforms: [
        .iOS(.v17),
        .macOS(.v14)
    ],
    products: [
        .library(
            name: "SkiTrailsCore",
            targets: ["SkiTrailsCore"]
        )
    ],
    dependencies: [
        .package(url: "https://github.com/mapbox/mapbox-maps-ios.git", "10.16.0"..<"11.0.0"),
        .package(url: "https://github.com/mapbox/turf-swift.git", exact: "2.8.0")
    ],
    targets: [
        .target(
            name: "SkiTrailsCore",
            dependencies: [
                .product(name: "MapboxMaps", package: "mapbox-maps-ios"),
                .product(name: "Turf", package: "turf-swift")
            ],
            path: "Sources/SkiTrailsCore"
        ),
        .executableTarget(
            name: "SkiTrails",
            dependencies: [
                "SkiTrailsCore",
                .product(name: "MapboxMaps", package: "mapbox-maps-ios"),
                .product(name: "Turf", package: "turf-swift")
            ],
            path: "App/SkiTrails"
        ),
        .testTarget(
            name: "SkiTrailsCoreTests",
            dependencies: ["SkiTrailsCore"]
        )
    ]
) 

### File: README.md


### File: envmirror.md
# Environment configuration for the Ski Resort Mapping App

# 3D Map Rendering API
MAPBOX_ACCESS_TOKEN=your_mapbox_token_here

# Real-Time Weather and Snow Data APIs
WEATHER_UNLOCKED_API_KEY=your_weather_unlocked_api_key_here
WEATHER_UNLOCKED_APP_ID=your_weather_unlocked_app_id_here

SKI_API_KEY=your_ski_api_key_here

# Liftie API Configuration
LIFTIE_API_BASE_URL=https://liftie.info/api/resort
LIFTIE_REFRESH_INTERVAL=65000
LIFTIE_RESORT_LIST=alpine,palisades

# Ski Resorts Information API
Ski_Resorts_Information_API-KEY=your_ski_resorts_information_api_key_here

# Navigation and Routing
NAVIGATION_API_KEY=your_navigation_api_key_here
GRAPHQL_ENDPOINT=your_graphql_endpoint_here
GRAPHQL_AUTH_TOKEN=your_graphql_auth_token_here

# Backend Server Configuration
API_BASE_URL=your_api_base_url_here
API_AUTH_TOKEN=your_api_auth_token_here

# Real-Time Updates
REALTIME_API_URL=your_realtime_api_url_here
REALTIME_API_KEY=your_realtime_api_key_here

# App Configuration
APP_ENV=development
DEBUG_MODE=true

# Firebase Configuration
FIREBASE_API_KEY=your_firebase_api_key_here
FIREBASE_PROJECT_ID=your_firebase_project_id_here
FIREBASE_MESSAGING_SENDER_ID=your_firebase_messaging_sender_id_here
FIREBASE_APP_ID=your_firebase_app_id_here

# Analytics and Logging
GOOGLE_ANALYTICS_KEY=your_google_analytics_key_here

SENTRY_DSN=your_sentry_dsn_here
# Custom Configuration
CUSTOM_3D_MODEL_URL=your_custom_3d_model_url_here 

### File: iOS-transition-todo.md
# iOS App Transition Plan

## 1. Create New Xcode Project
- [x] Create new iOS app project using SwiftUI template
- [x] Configure basic app settings (name, bundle ID, team)
- [x] Set minimum deployment target to iOS 17 (using 17.6)
- [x] Ensure SwiftUI lifecycle is selected (verified via SkiTrailsApp.swift)

## 2. Package Structure
### 2.1 Create Local Package
- [x] Create new local package "SkiTrailsCore" in SkiTrails-iOS project
- [x] Configure Package.swift with correct dependencies:
  - [x] MapboxMaps (10.16.0..<11.0.0)
  - [x] Turf (exact: 2.8.0)
- [x] Set platform requirements (iOS 17)

### 2.2 Directory Structure Migration
- [x] Create initial package structure:
  - [x] Sources/SkiTrailsCore/
  - [x] Tests/SkiTrailsCoreTests/
- [ ] Migrate core directories maintaining structure:
  - [ ] Routing/
  - [ ] Services/
  - [ ] Models/
  - [ ] ViewModels/
  - [ ] Configuration/

### 2.3 File Migration (with verification)
- [ ] For each directory:
  - [ ] Copy files
  - [ ] Verify imports
  - [ ] Test compilation
  - [ ] Document any issues or needed changes

### 2.4 Package Integration
- [ ] Add SkiTrailsCore package dependency to main app target
- [ ] Verify package builds independently
- [ ] Test package integration with main app

## 3. Code Migration
- [ ] Move app-specific code from App/SkiTrails to main app target
  - [ ] Views
  - [ ] ViewModels
  - [ ] App lifecycle code
  - [ ] Resources and assets
- [ ] Update import statements
- [ ] Fix any broken references

## 4. Resource Migration
- [ ] Move Images.xcassets to main app target
- [ ] Configure Info.plist
- [ ] Move any localization files
- [ ] Set up environment variables/configuration

## 5. Dependencies
- [ ] Set up Mapbox in main app target
- [ ] Configure any required capabilities
- [ ] Add any needed app-specific frameworks

## 6. Testing
- [ ] Verify all views render correctly
- [ ] Test navigation flow
- [ ] Verify map functionality
- [ ] Check all features work as expected
- [ ] Test on different iOS devices/simulators

## 7. Cleanup
- [ ] Remove old package-based project structure
- [ ] Update documentation
- [ ] Update any build scripts or workflows
- [ ] Archive old code if needed

## 8. Future Considerations
- [ ] Plan for visionOS support
- [ ] Consider watchOS companion app
- [ ] Plan for TestFlight distribution
- [ ] Set up CI/CD with Xcode Cloud

## Notes
- Keep the core functionality in SkiTrailsCore package for potential reuse
- Ensure proper separation of concerns between app and package
- Document any configuration requirements for future reference
- Organization identifier: Bens-Bots.SkiTrails 

### File: project.yml
name: SkiTrails
options:
  bundleIdPrefix: com.skitrails
  deploymentTarget:
    iOS: 17.0
packages:
  MapboxMaps:
    url: https://github.com/mapbox/mapbox-maps-ios.git
    from: 10.16.0
  Sentry:
    url: https://github.com/getsentry/sentry-cocoa.git
    from: 8.17.1
  SkiTrailsCore:
    path: ./
targets:
  SkiTrailsCore:
    type: framework
    platform: iOS
    sources:
      - path: Sources/SkiTrailsCore
    dependencies:
      - package: MapboxMaps
        product: MapboxMaps
      - package: Sentry
        product: Sentry
    settings:
      base:
        GENERATE_INFOPLIST_FILE: YES
        PRODUCT_BUNDLE_IDENTIFIER: com.skitrails.core
        CURRENT_PROJECT_VERSION: 1
        MARKETING_VERSION: 1.0.0
  SkiTrails:
    type: application
    platform: iOS
    sources: 
      - path: App/SkiTrails
        includes:
          - "**/*.swift"
        excludes:
          - "Resources/Info.plist"
    dependencies:
      - target: SkiTrailsCore
      - package: MapboxMaps
        product: MapboxMaps
      - package: Sentry
        product: Sentry
    settings:
      base:
        INFOPLIST_FILE: App/SkiTrails/Info.plist
        PRODUCT_BUNDLE_IDENTIFIER: com.skitrails.app
        DEVELOPMENT_TEAM: ""  # Add your team ID here if you have one
    info:
      path: App/SkiTrails/Info.plist
      properties:
        CFBundleName: SkiTrails
        CFBundleDisplayName: Ski Trails
        CFBundlePackageType: APPL
        UILaunchScreen: {}
        UISupportedInterfaceOrientations:
          - UIInterfaceOrientationPortrait
          - UIInterfaceOrientationLandscapeLeft
          - UIInterfaceOrientationLandscapeRight
        UIRequiredDeviceCapabilities:
          - armv7

### File: App/SkiTrails/Info.plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>$(DEVELOPMENT_LANGUAGE)</string>
	<key>CFBundleDisplayName</key>
	<string>Ski Trails</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>SkiTrails</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>1.0</string>
	<key>CFBundleVersion</key>
	<string>1</string>
	<key>UILaunchScreen</key>
	<dict/>
	<key>UIRequiredDeviceCapabilities</key>
	<array>
		<string>armv7</string>
	</array>
	<key>UISupportedInterfaceOrientations</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
</dict>
</plist>


### File: App/SkiTrails/SkiTrailsApp.swift
import SwiftUI
// import Sentry
import SkiTrailsCore

@main
struct SkiTrailsApp: App {
    @StateObject private var appState = AppState()
    
    init() {
        // Sentry initialization temporarily removed
        /*
        do {
            let dsn = try CoreConfig.getDSN()
            SentrySDK.start { options in
                options.dsn = dsn
                options.debug = true
                options.tracesSampleRate = 1.0
                options.enableSwizzling = true
            }
        } catch let error as CoreConfig.Error {
            switch error {
            case .missingKey(let key):
                print("Failed to initialize Sentry: Missing key \(key) in environment")
            case .invalidURLFormat(let url):
                print("Failed to initialize Sentry: Invalid URL format for \(url)")
            }
        } catch {
            print("Failed to initialize Sentry: \(error.localizedDescription)")
        }
        */
    }
    
    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(appState)
        }
    }
} 


### File: App/SkiTrails/Bundle.docc/Configuration.plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>CFBundleIdentifier</key>
    <string>com.skitrails.app</string>
    <key>CFBundleInfoDictionaryVersion</key>
    <string>6.0</string>
    <key>CFBundleName</key>
    <string>SkiTrails</string>
    <key>CFBundlePackageType</key>
    <string>APPL</string>
    <key>CFBundleShortVersionString</key>
    <string>1.0</string>
    <key>CFBundleVersion</key>
    <string>1</string>
    <key>LSRequiresIPhoneOS</key>
    <true/>
    <key>UILaunchStoryboardName</key>
    <string>LaunchScreen</string>
    <key>UIRequiredDeviceCapabilities</key>
    <array>
        <string>armv7</string>
    </array>
    <key>UISupportedInterfaceOrientations</key>
    <array>
        <string>UIInterfaceOrientationPortrait</string>
        <string>UIInterfaceOrientationLandscapeLeft</string>
        <string>UIInterfaceOrientationLandscapeRight</string>
    </array>
</dict>
</plist> 

### File: App/SkiTrails/Bundle.docc/Info.plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>NSLocationWhenInUseUsageDescription</key>
    <string>We need your location to show you where you are on the ski resort map and provide turn-by-turn navigation.</string>
    <key>NSLocationAlwaysAndWhenInUseUsageDescription</key>
    <string>We need your location to show you where you are on the ski resort map and provide turn-by-turn navigation, even when the app is in the background.</string>
    <key>NSLocationAlwaysUsageDescription</key>
    <string>We need your location to show you where you are on the ski resort map and provide turn-by-turn navigation, even when the app is in the background.</string>
    <key>NSCameraUsageDescription</key>
    <string>We need camera access to show ski runs in augmented reality overlaid on the mountain.</string>
    <key>UIBackgroundModes</key>
    <array>
        <string>location</string>
    </array>
    <key>CFBundleURLTypes</key>
    <array>
        <dict>
            <key>CFBundleURLSchemes</key>
            <array>
                <string>skitrails</string>
            </array>
            <key>CFBundleURLName</key>
            <string>com.skitrails.app</string>
        </dict>
    </array>
</dict>
</plist> 

### File: App/SkiTrails/ViewModels/ContentViewModel.swift
import SwiftUI
import CoreLocation

@MainActor
class ContentViewModel: ObservableObject {
    @Published var routeCoordinates: [CLLocationCoordinate2D] = []
    @Published private(set) var isLoading = false
    @Published private(set) var error: Error?
    
    func setLoading(_ loading: Bool) {
        isLoading = loading
    }
    
    func handleError(_ error: Error) {
        self.error = error
    }
    
    func clearRoute() {
        routeCoordinates = []
    }
} 

### File: App/SkiTrails/ViewModels/MapViewModel.swift
import SwiftUI
import CoreLocation
import SkiTrailsCore

class MapViewModel: ObservableObject {
    @Published var selectedFeature: MapFeature?
    
    let defaultCenter = CLLocationCoordinate2D(latitude: 39.6403, longitude: -106.3742) // Vail, CO
    let defaultZoom = 14.0
    let defaultPitch = 45.0
    let defaultBearing = 0.0
} 

### File: App/SkiTrails/ViewModels/NavigationViewModel.swift
import SwiftUI
import SkiTrailsCore
import CoreLocation

@MainActor
class NavigationViewModel: ObservableObject {
    @Published var skillLevel: Run.Difficulty = .intermediate
    @Published var avoidCrowds = false
    @Published var preferLessStrenuous = false
    @Published var showRouteSelection = false
    @Published var startPoint: Run?
    @Published var endPoint: Run?
    @Published var currentRoute: Route?
    @Published var isNavigating = false
    @Published var nextInstruction: NavigationInstruction?
    
    struct NavigationInstruction {
        let text: String
        let icon: String
    }
    
    private var appState: AppState
    
    init(appState: AppState) {
        self.appState = appState
    }
    
    func updateAppState(_ newAppState: AppState) {
        self.appState = newAppState
    }
    
    @MainActor
    static func create() async -> NavigationViewModel {
        let appState = AppState()
        return NavigationViewModel(appState: appState)
    }
    
    var canStartNavigation: Bool {
        endPoint != nil && (startPoint != nil || appState.locationManager.currentLocation != nil)
    }
    
    func startNavigation() async {
        guard let endPoint else { return }
        
        let preferences = RoutePreferences(
            avoidCrowds: avoidCrowds,
            preferLessStrenuous: preferLessStrenuous
        )
        
        do {
            if let startPoint {
                currentRoute = try await RoutingEngine.shared.findRoute(
                    from: CLLocationCoordinate2D(
                        latitude: startPoint.startLocation.latitude,
                        longitude: startPoint.startLocation.longitude
                    ),
                    to: CLLocationCoordinate2D(
                        latitude: endPoint.endLocation.latitude,
                        longitude: endPoint.endLocation.longitude
                    ),
                    difficulty: skillLevel,
                    preferences: preferences
                )
            } else if let currentLocation = appState.locationManager.currentLocation {
                // Use current location
                currentRoute = try await RoutingEngine.shared.findRoute(
                    from: currentLocation.coordinate,
                    to: CLLocationCoordinate2D(
                        latitude: endPoint.endLocation.latitude,
                        longitude: endPoint.endLocation.longitude
                    ),
                    difficulty: skillLevel,
                    preferences: preferences
                )
            } else {
                await ErrorHandler.shared.handle(NavigationError.noCurrentLocation)
                return
            }
            
            isNavigating = true
        } catch {
            await ErrorHandler.shared.handle(error)
        }
    }
    
    func stopNavigation() {
        isNavigating = false
        currentRoute = nil
        startPoint = nil
        endPoint = nil
    }
    
    enum NavigationError: LocalizedError {
        case noCurrentLocation
        
        var errorDescription: String? {
            switch self {
            case .noCurrentLocation:
                return "Unable to get current location. Please ensure location services are enabled."
            }
        }
    }
} 

### File: App/SkiTrails/ViewModels/ResortViewModel.swift
import SwiftUI
import SkiTrailsCore
import Combine

@MainActor
class ResortViewModel: ObservableObject {
    @Published private(set) var selectedResort: Resort?
    @Published private(set) var isLoading = false
    @Published private(set) var error: Error?
    
    private var statusRefreshTask: Task<Void, Never>?
    private let refreshInterval: TimeInterval = 60 // Refresh every minute
    private var isActive = false
    
    init() {}
    
    deinit {
        statusRefreshTask?.cancel()
        statusRefreshTask = nil
    }
    
    func onAppear() {
        isActive = true
        startStatusRefreshTimer()
    }
    
    func onDisappear() {
        isActive = false
        stopStatusRefresh()
    }
    
    func selectResort(_ resort: Resort) {
        selectedResort = resort
        if isActive {
            startStatusRefreshTimer()
        }
    }
    
    private func startStatusRefreshTimer() {
        stopStatusRefresh()
        statusRefreshTask = Task {
            while !Task.isCancelled && isActive {
                await refreshResortStatus()
                try? await Task.sleep(nanoseconds: UInt64(refreshInterval * 1_000_000_000))
            }
        }
    }
    
    private func stopStatusRefresh() {
        statusRefreshTask?.cancel()
        statusRefreshTask = nil
    }
    
    func refreshResortStatus() async {
        guard let resort = selectedResort else { return }
        do {
            isLoading = true
            let updatedResort = try await APIClient.shared.fetchResortInfo(id: resort.id.rawValue)
            if isActive { // Check if still active before updating UI
                selectedResort = updatedResort
                isLoading = false
            }
        } catch {
            if isActive { // Check if still active before updating UI
                self.error = error
                isLoading = false
            }
        }
    }
} 

### File: App/SkiTrails/Utils/EnvConfig.swift
import Foundation

/// A utility struct that provides type-safe access to environment variables
enum EnvConfig {
    static let isDebugMode = true
    
    // MARK: - Map Rendering
    static var mapboxAccessToken: String {
        ProcessInfo.processInfo.environment["MAPBOX_ACCESS_TOKEN"] ?? ""
    }
    
    // MARK: - Weather and Snow Data
    static var weatherUnlockedApiKey: String {
        ProcessInfo.processInfo.environment["WEATHER_UNLOCKED_API_KEY"] ?? ""
    }
    
    static var weatherUnlockedAppId: String {
        ProcessInfo.processInfo.environment["WEATHER_UNLOCKED_APP_ID"] ?? ""
    }
    
    static var skiApiKey: String {
        ProcessInfo.processInfo.environment["SKI_API_KEY"] ?? ""
    }
    
    // MARK: - Liftie API
    static var liftieApiBaseUrl: String {
        ProcessInfo.processInfo.environment["LIFTIE_API_BASE_URL"] ?? "https://liftie.info/api/resort"
    }
    
    static var liftieRefreshInterval: TimeInterval {
        Double(ProcessInfo.processInfo.environment["LIFTIE_REFRESH_INTERVAL"] ?? "65000") ?? 65000
    }
    
    static var liftieResortList: [String] {
        let list = ProcessInfo.processInfo.environment["LIFTIE_RESORT_LIST"] ?? ""
        return list.split(separator: ",").map(String.init)
    }
    
    // MARK: - Ski Resorts Information
    static var skiResortsInformationApiKey: String {
        ProcessInfo.processInfo.environment["SKI_RESORTS_INFORMATION_API_KEY"] ?? ""
    }
    
    // MARK: - Navigation and Routing
    static var navigationApiKey: String {
        ProcessInfo.processInfo.environment["NAVIGATION_API_KEY"] ?? ""
    }
    
    static var graphqlEndpoint: String {
        ProcessInfo.processInfo.environment["GRAPHQL_ENDPOINT"] ?? ""
    }
    
    static var graphqlAuthToken: String {
        ProcessInfo.processInfo.environment["GRAPHQL_AUTH_TOKEN"] ?? ""
    }
    
    // MARK: - Backend Configuration
    static var apiBaseUrl: String {
        ProcessInfo.processInfo.environment["API_BASE_URL"] ?? ""
    }
    
    static var apiAuthToken: String {
        ProcessInfo.processInfo.environment["API_AUTH_TOKEN"] ?? ""
    }
    
    // MARK: - Real-Time Updates
    static var realtimeApiUrl: String {
        ProcessInfo.processInfo.environment["REALTIME_API_URL"] ?? ""
    }
    
    static var realtimeApiKey: String {
        ProcessInfo.processInfo.environment["REALTIME_API_KEY"] ?? ""
    }
    
    // MARK: - App Configuration
    static var isDevelopment: Bool {
        ProcessInfo.processInfo.environment["APP_ENV"]?.lowercased() == "development"
    }
    
    // MARK: - Firebase
    static var firebaseApiKey: String {
        ProcessInfo.processInfo.environment["FIREBASE_API_KEY"] ?? ""
    }
    
    static var firebaseProjectId: String {
        ProcessInfo.processInfo.environment["FIREBASE_PROJECT_ID"] ?? ""
    }
    
    static var firebaseMessagingSenderId: String {
        ProcessInfo.processInfo.environment["FIREBASE_MESSAGING_SENDER_ID"] ?? ""
    }
    
    static var firebaseAppId: String {
        ProcessInfo.processInfo.environment["FIREBASE_APP_ID"] ?? ""
    }
    
    // MARK: - Analytics and Logging
    static var googleAnalyticsKey: String {
        ProcessInfo.processInfo.environment["GOOGLE_ANALYTICS_KEY"] ?? ""
    }
    
    static var sentryDsn: String {
        ProcessInfo.processInfo.environment["SENTRY_DSN"] ?? ""
    }
    
    // MARK: - Custom Configuration
    static var custom3dModelUrl: String {
        ProcessInfo.processInfo.environment["CUSTOM_3D_MODEL_URL"] ?? ""
    }
    
    // MARK: - Validation
    
    /// Validates that all required environment variables are present
    static func validateRequiredVariables() throws {
        let requiredVariables = [
            ("MAPBOX_ACCESS_TOKEN", mapboxAccessToken),
            ("WEATHER_UNLOCKED_API_KEY", weatherUnlockedApiKey),
            ("WEATHER_UNLOCKED_APP_ID", weatherUnlockedAppId),
            ("SKI_API_KEY", skiApiKey)
        ]
        
        let missingVariables = requiredVariables
            .filter { $0.1.isEmpty }
            .map { $0.0 }
        
        guard missingVariables.isEmpty else {
            throw EnvConfigError.missingRequiredVariables(missingVariables)
        }
    }
}

// MARK: - Error Types

enum EnvConfigError: LocalizedError {
    case missingRequiredVariables([String])
    
    var errorDescription: String? {
        switch self {
        case .missingRequiredVariables(let variables):
            return "Missing required environment variables: \(variables.joined(separator: ", "))"
        }
    }
} 

### File: App/SkiTrails/Utils/MapConfig.swift
import Foundation

enum MapConfig {
    enum MapConfigError: LocalizedError {
        case missingAccessToken
        
        var errorDescription: String? {
            switch self {
            case .missingAccessToken:
                return "Missing Mapbox access token"
            }
        }
    }
    
    static func getMapboxAccessToken() throws -> String {
        if let token = ProcessInfo.processInfo.environment["MAPBOX_ACCESS_TOKEN"] {
            return token
        }
        if let token = Bundle.main.object(forInfoDictionaryKey: "MGLMapboxAccessToken") as? String {
            return token
        }
        throw MapConfigError.missingAccessToken
    }
} 

### File: App/SkiTrails/Models/AppState.swift
import SwiftUI
import Combine
import CoreLocation
import Foundation
import SkiTrailsCore

@MainActor
class AppState: ObservableObject {
    @Published var resorts: [Resort] = []
    @Published var selectedResort: Resort?
    @Published var activeRoute: Route?
    @Published var locationManager = LocationManager()
    
    private let apiClient = APIClient.shared
    private let errorHandler = ErrorHandler.shared
    
    init() {
        locationManager.requestAuthorization()
    }
    
    static var preview: AppState {
        let state = AppState()
        state.resorts = [Resort.preview]
        state.selectedResort = Resort.preview
        return state
    }
    
    func loadResorts() async {
        do {
            resorts = try await apiClient.fetchResortList()
        } catch {
            await errorHandler.handle(error)
        }
    }
} 


### File: App/SkiTrails/Models/HeavenlyData.swift
import Foundation
import MapboxMaps
import Combine

class HeavenlyData: ObservableObject {
    @Published private(set) var boundaries: String?
    @Published private(set) var runs: String?
    @Published private(set) var lifts: String?
    @Published private(set) var isLoading = false
    @Published private(set) var error: Error?
    
    private let dataService = ResortDataService()
    private var cancellables = Set<AnyCancellable>()
    
    static let shared = HeavenlyData()
    
    private init() {
        // Subscribe to data service updates
        dataService.$boundaries
            .assign(to: &$boundaries)
        
        dataService.$runs
            .assign(to: &$runs)
        
        dataService.$lifts
            .assign(to: &$lifts)
        
        dataService.$isLoading
            .assign(to: &$isLoading)
        
        dataService.$error
            .assign(to: &$error)
        
        // Fetch initial data
        fetchData()
    }
    
    func fetchData() {
        dataService.fetchResortData(resortId: "heavenly")
    }
    
    // Fallback data in case API is not available
    static let fallbackBoundaries: String = """
    {
        "type": "Feature",
        "geometry": {
            "type": "Polygon",
            "coordinates": [[
                [-119.9500, 38.9300],
                [-119.9500, 38.9400],
                [-119.9300, 38.9400],
                [-119.9300, 38.9300],
                [-119.9500, 38.9300]
            ]]
        },
        "properties": {
            "name": "Heavenly Mountain Resort"
        }
    }
    """
    
    static let fallbackRuns: String = """
    {
        "type": "FeatureCollection",
        "features": [
            {
                "type": "Feature",
                "geometry": {
                    "type": "Polygon",
                    "coordinates": [[
                        [-119.9400, 38.9350],
                        [-119.9400, 38.9370],
                        [-119.9380, 38.9370],
                        [-119.9380, 38.9350],
                        [-119.9400, 38.9350]
                    ]]
                },
                "properties": {
                    "name": "Ridge Run",
                    "difficulty": "blue",
                    "status": "open"
                }
            },
            {
                "type": "Feature",
                "geometry": {
                    "type": "Polygon",
                    "coordinates": [[
                        [-119.9380, 38.9350],
                        [-119.9380, 38.9370],
                        [-119.9360, 38.9370],
                        [-119.9360, 38.9350],
                        [-119.9380, 38.9350]
                    ]]
                },
                "properties": {
                    "name": "Orion's Run",
                    "difficulty": "black",
                    "status": "open"
                }
            },
            {
                "type": "Feature",
                "geometry": {
                    "type": "Polygon",
                    "coordinates": [[
                        [-119.9420, 38.9350],
                        [-119.9420, 38.9370],
                        [-119.9400, 38.9370],
                        [-119.9400, 38.9350],
                        [-119.9420, 38.9350]
                    ]]
                },
                "properties": {
                    "name": "Comet Run",
                    "difficulty": "green",
                    "status": "open"
                }
            }
        ]
    }
    """
    
    static let fallbackLifts: String = """
    {
        "type": "FeatureCollection",
        "features": [
            {
                "type": "Feature",
                "geometry": {
                    "type": "LineString",
                    "coordinates": [
                        [-119.9450, 38.9320],
                        [-119.9400, 38.9380]
                    ]
                },
                "properties": {
                    "name": "Gondola",
                    "type": "gondola",
                    "status": "operating"
                }
            },
            {
                "type": "Feature",
                "geometry": {
                    "type": "LineString",
                    "coordinates": [
                        [-119.9380, 38.9320],
                        [-119.9350, 38.9380]
                    ]
                },
                "properties": {
                    "name": "Comet Express",
                    "type": "chairlift",
                    "status": "operating"
                }
            }
        ]
    }
    """
} 

### File: App/SkiTrails/Models/Status.swift
import SwiftUI

enum Status: String, Codable {
    case open
    case closed
    case hold
    case scheduled
    case grooming
    
    var color: Color {
        switch self {
        case .open:
            return .green
        case .closed:
            return .red
        case .hold:
            return .orange
        case .scheduled:
            return .blue
        case .grooming:
            return .purple
        }
    }
} 

### File: App/SkiTrails/Models/TrailDifficulty.swift
import SwiftUI

enum TrailDifficulty: String, Codable {
    case beginner = "green"
    case intermediate = "blue"
    case advanced = "black"
    case expert = "double_black"
    
    var description: String {
        switch self {
        case .beginner:
            return "Beginner"
        case .intermediate:
            return "Intermediate"
        case .advanced:
            return "Advanced"
        case .expert:
            return "Expert"
        }
    }
} 

### File: App/SkiTrails/Extensions/SkiDifficulty+Color.swift
import SwiftUI
import SkiTrailsCore

extension SkiDifficulty {
    var color: Color {
        switch self {
        case .beginner:
            return .green
        case .intermediate:
            return .blue
        case .advanced:
            return .black
        case .expert:
            return .black
        }
    }
} 

### File: App/SkiTrails/Images.xcassets/Contents.json
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
} 

### File: App/SkiTrails/Images.xcassets/AppIcon.appiconset/Contents.json
{
  "images" : [
    {
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "20x20"
    },
    {
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "20x20"
    },
    {
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "29x29"
    },
    {
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "29x29"
    },
    {
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "40x40"
    },
    {
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "40x40"
    },
    {
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "60x60"
    },
    {
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "60x60"
    },
    {
      "idiom" : "ios-marketing",
      "scale" : "1x",
      "size" : "1024x1024"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
} 

### File: App/SkiTrails/Views/ActiveNavigationView.swift
import SwiftUI
import SkiTrailsCore

typealias NavigationInstruction = NavigationViewModel.NavigationInstruction

struct ActiveNavigationView: View {
    @ObservedObject var viewModel: NavigationViewModel
    @EnvironmentObject private var appState: AppState
    
    var body: some View {
        NavigationView {
            Group {
                if let route = viewModel.currentRoute {
                    RouteContentView(route: route, viewModel: viewModel)
                } else {
                    ProgressView()
                }
            }
            .navigationTitle("Navigation")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Stop") {
                        viewModel.stopNavigation()
                    }
                }
            }
        }
    }
}

private struct RouteContentView: View {
    let route: Route
    let viewModel: NavigationViewModel
    
    var body: some View {
        VStack(spacing: 0) {
            RouteOverlayView(route: route)
                .frame(maxHeight: .infinity)
            
            RouteInfoView(route: route, viewModel: viewModel)
        }
    }
}

private struct RouteInfoView: View {
    let route: Route
    let viewModel: NavigationViewModel
    
    var body: some View {
        VStack(spacing: 16) {
            if let nextInstruction = viewModel.nextInstruction {
                NextInstructionView(instruction: nextInstruction)
            }
            
            RouteStatsView(route: route)
            
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 12) {
                    ForEach(route.segments.indices, id: \.self) { index in
                        SegmentCard(segment: route.segments[index])
                    }
                }
                .padding(.horizontal)
            }
        }
        .padding(.vertical)
        .background(.ultraThinMaterial)
    }
}

private struct NextInstructionView: View {
    let instruction: NavigationInstruction
    
    var body: some View {
        HStack {
            Image(systemName: instruction.icon)
                .font(.title2)
            Text(instruction.text)
                .font(.headline)
        }
        .padding()
        .frame(maxWidth: .infinity)
        .background(.ultraThinMaterial)
    }
}

private struct RouteStatsView: View {
    let route: Route
    
    var body: some View {
        HStack {
            Label(
                "\(Int(route.totalDistance)) meters",
                systemImage: "ruler"
            )
            
            Spacer()
            
            Label(
                formatDuration(route.estimatedTime),
                systemImage: "clock"
            )
        }
        .font(.headline)
        .padding(.horizontal)
    }
    
    private func formatDuration(_ seconds: TimeInterval) -> String {
        let minutes = Int(seconds / 60)
        return "\(minutes) min"
    }
}

struct SegmentCard: View {
    let segment: Route.Segment
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                Image(systemName: iconName)
                    .foregroundColor(iconColor)
                
                Text(segmentName)
                    .font(.headline)
            }
            
            if case .run(let run) = segment.type {
                DifficultyIndicator(difficulty: run.difficulty)
            }
            
            Text("\(Int(segment.distance)) meters")
                .font(.caption)
                .foregroundColor(.secondary)
        }
        .padding()
        .background(Color(uiColor: .secondarySystemGroupedBackground))
        .clipShape(RoundedRectangle(cornerRadius: 12))
    }
    
    private var iconName: String {
        switch segment.type {
        case .run:
            return "arrow.down.forward.circle.fill"
        case .lift:
            return "arrow.up.forward.circle.fill"
        case .connection:
            return "arrow.right.circle.fill"
        }
    }
    
    private var iconColor: Color {
        switch segment.type {
        case .run:
            return .blue
        case .lift:
            return .green
        case .connection:
            return .orange
        }
    }
    
    private var segmentName: String {
        switch segment.type {
        case .run(let run):
            return run.name
        case .lift(let lift):
            return lift.name
        case .connection:
            return "Connection"
        }
    }
}

#Preview {
    let appState = AppState()
    return ActiveNavigationView(viewModel: NavigationViewModel(appState: appState))
        .environmentObject(appState)
} 


### File: App/SkiTrails/Views/ErrorAlertView.swift
import SwiftUI

struct ErrorAlertView: View {
    let error: UserFacingError
    let dismissAction: () -> Void
    
    var body: some View {
        VStack {
            Spacer()
            
            VStack(spacing: 16) {
                // Error Icon
                Image(systemName: "exclamationmark.triangle.fill")
                    .font(.largeTitle)
                    .foregroundColor(.red)
                
                // Error Title
                Text(error.title)
                    .font(.headline)
                
                // Error Message
                Text(error.message)
                    .font(.subheadline)
                    .multilineTextAlignment(.center)
                
                // Recovery Suggestion
                if let suggestion = error.recoverySuggestion {
                    Text(suggestion)
                        .font(.caption)
                        .foregroundColor(.secondary)
                        .multilineTextAlignment(.center)
                }
                
                // Dismiss Button
                Button("Dismiss") {
                    dismissAction()
                }
                .buttonStyle(.borderedProminent)
            }
            .padding()
            .background(.ultraThinMaterial)
            .cornerRadius(10)
            .padding()
            
            Spacer()
        }
        .background(Color.black.opacity(0.4))
        .ignoresSafeArea()
    }
}

// MARK: - Preview

#Preview {
    ErrorAlertView(
        error: UserFacingError(
            title: "Network Error",
            message: "Failed to load resort data",
            recoverySuggestion: "Please check your internet connection and try again."
        )
    ) {
        // Dismiss action
    }
} 

### File: App/SkiTrails/Views/MapSelectionView.swift
import SwiftUI
import MapKit
import CoreLocation

struct MapSelectionView: View {
    @Environment(\.dismiss) private var dismiss
    @Binding var coordinate: CLLocationCoordinate2D?
    let title: String
    
    @State private var region = MKCoordinateRegion(
        center: CLLocationCoordinate2D(latitude: 37.7749, longitude: -122.4194),
        span: MKCoordinateSpan(latitudeDelta: 0.1, longitudeDelta: 0.1)
    )
    
    private var annotations: [IdentifiableCoordinate] {
        if let coordinate = coordinate {
            return [IdentifiableCoordinate(coordinate: coordinate)]
        }
        return []
    }
    
    var body: some View {
        NavigationStack {
            Map {
                ForEach(annotations) { annotation in
                    Marker("Selected Location", coordinate: annotation.coordinate)
                }
                UserAnnotation()
            }
            .mapControls {
                MapUserLocationButton()
                MapCompass()
            }
            .onTapGesture { _ in
                withAnimation {
                    coordinate = region.center
                }
            }
            .navigationTitle(title)
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") { dismiss() }
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("Done") { dismiss() }
                    .disabled(coordinate == nil)
                }
            }
        }
    }
}

private struct IdentifiableCoordinate: Identifiable {
    let id = UUID()
    let coordinate: CLLocationCoordinate2D
}

#Preview {
    MapSelectionView(
        coordinate: .constant(nil),
        title: "Select Location"
    )
} 

### File: App/SkiTrails/Views/MapView.swift
import SwiftUI
import MapboxMaps
import SkiTrailsCore

struct SkiMapView: View {
    @StateObject private var viewModel = MapViewModel()
    @EnvironmentObject private var appState: AppState
    
    var body: some View {
        ZStack {
            MapViewRepresentable(
                selectedFeature: $viewModel.selectedFeature
            )
            
            if let feature = viewModel.selectedFeature {
                VStack {
                    Spacer()
                    FeatureDetailCard(feature: feature)
                        .padding()
                }
            }
        }
        .edgesIgnoringSafeArea(.all)
    }
}

struct MapViewRepresentable: UIViewControllerRepresentable {
    @Binding var selectedFeature: MapFeature?
    
    func makeUIViewController(context: Context) -> MapViewController {
        let viewController = MapViewController()
        viewController.delegate = context.coordinator
        return viewController
    }
    
    func updateUIViewController(_ uiViewController: MapViewController, context: Context) {
        // Update view controller if needed
    }
    
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    
    class Coordinator: NSObject, MapViewControllerDelegate {
        var parent: MapViewRepresentable
        
        init(_ parent: MapViewRepresentable) {
            self.parent = parent
        }
        
        func mapViewController(_ controller: MapViewController, didSelect feature: MapFeature) {
            parent.selectedFeature = feature
        }
    }
}

class MapViewController: UIViewController {
    weak var delegate: MapViewControllerDelegate?
    private var mapView: MapboxMaps.MapView?
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setupMapView()
    }
    
    private func setupMapView() {
        do {
            let accessToken = try MapConfig.getMapboxAccessToken()
            let resourceOptions = ResourceOptions(accessToken: accessToken)
            let mapInitOptions = MapInitOptions(resourceOptions: resourceOptions)
            
            let mapView = MapboxMaps.MapView(frame: view.bounds, mapInitOptions: mapInitOptions)
            mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight]
            
            view.addSubview(mapView)
            self.mapView = mapView
            
            // Configure map style and camera
            mapView.mapboxMap.loadStyleURI(.outdoors)
            
            // Set initial camera position
            let camera = CameraOptions(
                center: CLLocationCoordinate2D(latitude: 39.6403, longitude: -106.3742),
                zoom: 14,
                bearing: 0,
                pitch: 45
            )
            mapView.camera.fly(to: camera, duration: 0)
            
        } catch {
            print("Failed to initialize map: \(error.localizedDescription)")
        }
    }
}

protocol MapViewControllerDelegate: AnyObject {
    func mapViewController(_ controller: MapViewController, didSelect feature: MapFeature)
}

struct FeatureDetailCard: View {
    let feature: MapFeature
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text(feature.name)
                .font(.headline)
            
            switch feature {
            case .run(let run):
                RunDetailView(run: run)
            case .lift(let lift):
                LiftDetailView(lift: lift)
            case .point(_, _, _):
                EmptyView()
            }
        }
        .padding()
        .background(Color(.systemBackground))
        .cornerRadius(12)
        .shadow(radius: 5)
    }
}

struct RunDetailView: View {
    let run: Run
    
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            HStack {
                Text("Difficulty:")
                Text(run.difficulty.rawValue.capitalized)
            }
            HStack {
                Text("Status:")
                Text(run.status.rawValue.capitalized)
            }
            HStack {
                Text("Length:")
                Text(String(format: "%.1f km", run.length / 1000))
            }
            HStack {
                Text("Vertical:")
                Text(String(format: "%.0f m", run.verticalDrop))
            }
        }
    }
}

struct LiftDetailView: View {
    let lift: Lift
    
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            HStack {
                Text("Status:")
                Text(lift.status.rawValue.capitalized)
            }
            HStack {
                Text("Capacity:")
                Text("\(lift.capacity) riders")
            }
            if let waitTime = lift.waitTime {
                HStack {
                    Text("Wait Time:")
                    Text(String(format: "%.0f min", waitTime / 60))
                }
            }
        }
    }
} 

### File: App/SkiTrails/Views/MapboxMapView.swift
import SwiftUI
import MapboxMaps
import CoreLocation
import SkiTrailsCore
import UIKit

struct MapboxMapView: UIViewRepresentable {
    typealias UIViewType = UIView
    
    let initialCoordinates: CLLocationCoordinate2D
    let initialZoom: Double
    let initialPitch: Double
    let initialBearing: Double
    @Binding var selectedFeature: MapFeature?
    
    func makeUIView(context: Context) -> UIView {
        let resourceOptions = ResourceOptions(accessToken: EnvConfig.mapboxAccessToken)
        let cameraOptions = CameraOptions(
            center: initialCoordinates,
            zoom: initialZoom,
            bearing: initialBearing,
            pitch: initialPitch
        )
        let initOptions = MapInitOptions(resourceOptions: resourceOptions,
                                       cameraOptions: cameraOptions)
        
        let containerView = UIView()
        containerView.autoresizingMask = [.flexibleWidth, .flexibleHeight]
        
        let mapView = MapboxMaps.MapView(frame: containerView.bounds, mapInitOptions: initOptions)
        mapView.autoresizingMask = [.flexibleWidth, .flexibleHeight]
        containerView.addSubview(mapView)
        
        // Store mapView in coordinator for later access
        context.coordinator.mapView = mapView
        
        // Observe style loaded event
        mapView.mapboxMap.onNext(event: .styleLoaded) { _ in
            // Map style finished loading
            // Add any style-dependent layers or sources here
        }
        
        return containerView
    }
    
    func updateUIView(_ uiView: UIView, context: Context) {
        guard let mapView = context.coordinator.mapView else { return }
        
        // Update selected feature if needed
        if let feature = selectedFeature {
            let coords = feature.coordinates
            let coordinate = CLLocationCoordinate2D(
                latitude: coords.latitude,
                longitude: coords.longitude
            )
            let camera = CameraOptions(center: coordinate, zoom: 15.0)
            mapView.camera.ease(to: camera, duration: 0.5)
        }
    }
    
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    
    class Coordinator: NSObject {
        var parent: MapboxMapView
        var mapView: MapboxMaps.MapView?
        
        init(_ parent: MapboxMapView) {
            self.parent = parent
        }
    }
} 

### File: App/SkiTrails/Views/RouteDetailView.swift
import SwiftUI
import SkiTrailsCore

struct RouteDetailView: View {
    let route: Route
    @Environment(\.dismiss) private var dismiss
    @EnvironmentObject private var appState: AppState
    
    var body: some View {
        List {
            // Route Summary
            Section {
                Label("Route Details", systemImage: "map")
                    .font(.headline)
                VStack(alignment: .leading, spacing: 8) {
                    HStack {
                        Label("\(Int(route.totalDistance))m", systemImage: "ruler")
                        Spacer()
                        Label(formatDuration(route.estimatedTime), systemImage: "clock")
                    }
                    
                    HStack {
                        Label("Difficulty", systemImage: "figure.skiing.downhill")
                        Spacer()
                        DifficultyIndicator(difficulty: route.difficulty)
                    }
                }
            } header: {
                Text("Summary")
            }
            
            // Route Segments
            Section {
                ForEach(route.segments.indices, id: \.self) { index in
                    let segment = route.segments[index]
                    RouteSegmentRow(segment: segment, index: index)
                }
            } header: {
                Text("Route Details")
            }
            
            // Actions
            Section {
                Button(action: {
                    startNavigation()
                }) {
                    Label("Start Navigation", systemImage: "location.fill")
                }
                .foregroundColor(.blue)
                
                Button(action: {
                    shareRoute()
                }) {
                    Label("Share Route", systemImage: "square.and.arrow.up")
                }
            } header: {
                Text("Actions")
            }
        }
        .navigationTitle("Route Details")
        .navigationBarTitleDisplayMode(.inline)
        .toolbar {
            ToolbarItem(placement: .navigationBarTrailing) {
                Button("Done") {
                    dismiss()
                }
            }
        }
    }
    
    private func formatDuration(_ timeInterval: TimeInterval) -> String {
        let formatter = DateComponentsFormatter()
        formatter.allowedUnits = [.hour, .minute]
        formatter.unitsStyle = .abbreviated
        return formatter.string(from: timeInterval) ?? ""
    }
    
    private func startNavigation() {
        appState.activeRoute = route
        dismiss()
    }
    
    private func shareRoute() {
        // Implement route sharing functionality
    }
}

struct RouteSegmentRow: View {
    let segment: Route.Segment
    let index: Int
    
    var body: some View {
        HStack(spacing: 12) {
            // Segment number
            ZStack {
                Circle()
                    .fill(.blue)
                    .frame(width: 24, height: 24)
                Text("\(index + 1)")
                    .foregroundColor(.white)
                    .font(.caption.bold())
            }
            
            // Segment details
            VStack(alignment: .leading, spacing: 4) {
                Text(segmentTitle)
                    .font(.headline)
                Text("\(Int(segment.distance))m")
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }
            
            Spacer()
            
            // Segment icon
            Image(systemName: segmentIcon)
                .foregroundColor(.blue)
        }
        .padding(.vertical, 4)
    }
    
    private var segmentTitle: String {
        switch segment.type {
        case .run(let run):
            return run.name
        case .lift(let lift):
            return lift.name
        case .connection:
            return "Connection"
        }
    }
    
    private var segmentIcon: String {
        switch segment.type {
        case .run:
            return "figure.skiing.downhill"
        case .lift:
            return "arrow.up"
        case .connection:
            return "arrow.right"
        }
    }
}

#if DEBUG
struct RouteDetailView_Previews: PreviewProvider {
    static var previews: some View {
        NavigationView {
            RouteDetailView(route: .preview)
                .environmentObject(AppState())
        }
    }
}
#endif

// MARK: - Preview Helpers
extension Route {
    static var preview: Route {
        let location1 = Route.Segment.Location(latitude: 0, longitude: 0, altitude: 0)
        let location2 = Route.Segment.Location(latitude: 1, longitude: 1, altitude: 100)
        let location3 = Route.Segment.Location(latitude: 2, longitude: 2, altitude: 0)
        
        return Route(
            segments: [
                Segment(
                    type: .lift(Lift(
                        id: EntityID(UUID()),
                        name: "Express Lift",
                        status: .open,
                        startLocation: Location(latitude: location1.latitude, longitude: location1.longitude, altitude: location1.altitude),
                        endLocation: Location(latitude: location2.latitude, longitude: location2.longitude, altitude: location2.altitude),
                        capacity: 4,
                        waitTime: 5
                    )),
                    path: [
                        location1,
                        location2
                    ],
                    distance: 1200
                ),
                Segment(
                    type: .run(Run(
                        id: EntityID(UUID()),
                        name: "Blue Run",
                        difficulty: .intermediate,
                        status: .open,
                        startLocation: Location(latitude: location2.latitude, longitude: location2.longitude, altitude: location2.altitude),
                        endLocation: Location(latitude: location3.latitude, longitude: location3.longitude, altitude: location3.altitude),
                        length: 800,
                        verticalDrop: 200
                    )),
                    path: [
                        location2,
                        location3
                    ],
                    distance: 800
                )
            ],
            totalDistance: 2000,
            estimatedTime: 1800, // 30 minutes
            difficulty: .intermediate
        )
    }
} 


### File: App/SkiTrails/Views/RouteOverlayView.swift
import SwiftUI
import MapboxMaps
import SkiTrailsCore
import Turf

struct RouteOverlayView: UIViewRepresentable {
    let route: Route
    
    func makeUIView(context: Context) -> MapboxMaps.MapView {
        let resourceOptions = ResourceOptions(accessToken: try! CoreConfig.getValue(for: "MAPBOX_ACCESS_TOKEN"))
        let mapInitOptions = MapInitOptions(resourceOptions: resourceOptions)
        let mapView = MapboxMaps.MapView(frame: .zero, mapInitOptions: mapInitOptions)
        
        mapView.mapboxMap.onNext(event: .styleLoaded) { _ in
            addRouteOverlay(to: mapView)
        }
        
        return mapView
    }
    
    func updateUIView(_ mapView: MapboxMaps.MapView, context: Context) {
        addRouteOverlay(to: mapView)
    }
    
    private func addRouteOverlay(to mapView: MapboxMaps.MapView) {
        let coordinates = route.segments.flatMap { segment -> [CLLocationCoordinate2D] in
            return segment.path.map { location in
                CLLocationCoordinate2D(
                    latitude: location.latitude,
                    longitude: location.longitude
                )
            }
        }
        
        do {
            var source = GeoJSONSource()
            let geometry = MapboxMaps.LineString(coordinates)
            let feature = MapboxMaps.Feature(geometry: geometry)
            source.data = .feature(feature)
            try mapView.mapboxMap.style.addSource(source, id: "route")
            
            var layer = LineLayer(id: "route-layer")
            layer.source = "route"
            layer.lineColor = .constant(.init(UIColor.systemBlue))
            layer.lineWidth = .constant(4)
            try mapView.mapboxMap.style.addLayer(layer)
            
            let camera = CameraOptions(center: coordinates[0], zoom: 15)
            mapView.camera.fly(to: camera, duration: 1.0)
        } catch {
            print("Error adding route overlay: \(error)")
        }
    }
}

#Preview {
    RouteOverlayView(
        route: Route(
            segments: [
                Route.Segment(
                    type: .run(Run(
                        id: EntityID(UUID()),
                        name: "Blue Heaven",
                        difficulty: .intermediate,
                        status: .open,
                        startLocation: Location(latitude: 40.5853, longitude: -111.6564, altitude: 2800),
                        endLocation: Location(latitude: 40.5845, longitude: -111.6558, altitude: 2600),
                        length: 500,
                        verticalDrop: 200
                    )),
                    path: [
                        Route.Segment.Location(latitude: 40.5853, longitude: -111.6564, altitude: 2800),
                        Route.Segment.Location(latitude: 40.5845, longitude: -111.6558, altitude: 2600)
                    ],
                    distance: 500
                )
            ],
            totalDistance: 500,
            estimatedTime: 300,
            difficulty: .intermediate
        )
    )
} 

### File: App/SkiTrails/Views/RouteSelectionView.swift
import SwiftUI
import SkiTrailsCore

struct RouteSelectionView: View {
    let resort: Resort
    @ObservedObject var viewModel: NavigationViewModel
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        NavigationView {
            Form {
                Section("Start Point") {
                    Picker("Select Start Point", selection: $viewModel.startPoint) {
                        Text("Current Location").tag(nil as Run?)
                        ForEach(resort.runs) { run in
                            Text(run.name).tag(run as Run?)
                        }
                    }
                }
                
                Section("End Point") {
                    Picker("Select End Point", selection: $viewModel.endPoint) {
                        ForEach(resort.runs) { run in
                            Text(run.name).tag(run as Run?)
                        }
                    }
                }
                
                Section {
                    Button("Start Navigation") {
                        Task {
                            await viewModel.startNavigation()
                            dismiss()
                        }
                    }
                    .disabled(!viewModel.canStartNavigation)
                }
            }
            .navigationTitle("Select Route")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
            }
        }
    }
}

#Preview {
    let resort = Resort.preview
    RouteSelectionView(
        resort: resort,
        viewModel: NavigationViewModel(appState: AppState.preview)
    )
    .environmentObject(AppState.preview)
} 


### File: App/SkiTrails/Views/Views.swift
import SwiftUI
import MapKit
import SkiTrailsCore

// MARK: - Common Views
struct DifficultyIndicator: View {
    let difficulty: Run.Difficulty
    
    var body: some View {
        HStack(spacing: 4) {
            Circle()
                .fill(color)
                .frame(width: 8, height: 8)
            
            Text(difficulty.rawValue.capitalized)
                .font(.caption)
                .foregroundColor(.secondary)
        }
    }
    
    private var color: Color {
        switch difficulty {
        case .beginner:
            return .green
        case .intermediate:
            return .blue
        case .advanced:
            return .black
        case .expert:
            return .red
        }
    }
}

struct StatusBadge: View {
    let status: String
    let color: Color
    
    init(liftStatus: Lift.Status) {
        self.status = liftStatus.rawValue.capitalized
        switch liftStatus {
        case .open:
            self.color = .green
        case .closed:
            self.color = .red
        case .onHold:
            self.color = .orange
        case .maintenance:
            self.color = .purple
        }
    }
    
    init(runStatus: Run.Status) {
        self.status = runStatus.rawValue.capitalized
        switch runStatus {
        case .open:
            self.color = .green
        case .closed:
            self.color = .red
        case .grooming:
            self.color = .purple
        }
    }
    
    var body: some View {
        Text(status)
            .font(.caption)
            .padding(.horizontal, 8)
            .padding(.vertical, 4)
            .background(color.opacity(0.2))
            .foregroundColor(color)
            .clipShape(Capsule())
    }
}

struct LiftStatusRow: View {
    let lift: Lift
    
    var body: some View {
        HStack {
            VStack(alignment: .leading) {
                Text(lift.name)
                    .font(.headline)
                
                if let waitTime = lift.waitTime {
                    Text("\(Int(waitTime / 60)) min wait")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
            }
            
            Spacer()
            
            StatusBadge(liftStatus: lift.status)
        }
        .padding(.vertical, 4)
    }
}

struct RunStatusRow: View {
    let run: Run
    
    var body: some View {
        HStack {
            VStack(alignment: .leading) {
                Text(run.name)
                    .font(.headline)
                
                DifficultyIndicator(difficulty: run.difficulty)
            }
            
            Spacer()
            
            StatusBadge(runStatus: run.status)
        }
        .padding(.vertical, 4)
    }
}

// MARK: - Content View
struct ContentView: View {
    @StateObject private var appState = AppState()
    @State private var selectedTab = 0
    
    var body: some View {
        TabView(selection: $selectedTab) {
            ResortListView()
                .tabItem {
                    Label("Resorts", systemImage: "list.bullet")
                }
                .tag(0)
            
            SkiMapView()
                .tabItem {
                    Label("Map", systemImage: "map")
                }
                .tag(1)
            
            TrailStatusView()
                .tabItem {
                    Label("Status", systemImage: "info.circle")
                }
                .tag(2)
            
            NavigationSetupView(viewModel: NavigationViewModel(appState: appState))
                .tabItem {
                    Label("Navigate", systemImage: "location.fill")
                }
                .tag(3)
            
            ARResortView()
                .tabItem {
                    Label("AR View", systemImage: "camera.fill")
                }
                .tag(4)
        }
        .environmentObject(appState)
    }
}

// MARK: - Resort List View
struct ResortListView: View {
    @StateObject private var viewModel = ResortViewModel()
    @EnvironmentObject private var appState: AppState
    
    var body: some View {
        NavigationView {
            Group {
                if viewModel.isLoading {
                    ProgressView()
                } else {
                    List(appState.resorts) { resort in
                        ResortRowView(resort: resort)
                            .onTapGesture {
                                viewModel.selectResort(resort)
                            }
                    }
                }
            }
            .navigationTitle("Ski Resorts")
            .task {
                await appState.loadResorts()
            }
            .onAppear {
                viewModel.onAppear()
            }
            .onDisappear {
                viewModel.onDisappear()
            }
        }
    }
}

// MARK: - Trail Status View
struct TrailStatusView: View {
    @EnvironmentObject private var appState: AppState
    @StateObject private var viewModel = ResortViewModel()
    
    var body: some View {
        NavigationView {
            Group {
                if viewModel.isLoading {
                    ProgressView()
                } else if let resort = appState.selectedResort {
                    List {
                        Section("Lifts") {
                            ForEach(resort.lifts) { lift in
                                LiftStatusRow(lift: lift)
                            }
                        }
                        
                        Section("Runs") {
                            ForEach(resort.runs) { run in
                                RunStatusRow(run: run)
                            }
                        }
                    }
                } else {
                    ContentUnavailableView(
                        "No Resort Selected",
                        systemImage: "mountain.2",
                        description: Text("Select a resort to view trail status")
                    )
                }
            }
            .navigationTitle("Trail Status")
            .refreshable {
                if appState.selectedResort != nil {
                    await viewModel.refreshResortStatus()
                }
            }
        }
    }
}

// MARK: - Navigation Setup View
struct NavigationSetupView: View {
    @StateObject private var viewModel: NavigationViewModel
    @EnvironmentObject private var appState: AppState
    
    init(viewModel: NavigationViewModel? = nil) {
        if let viewModel = viewModel {
            _viewModel = StateObject(wrappedValue: viewModel)
        } else {
            _viewModel = StateObject(wrappedValue: NavigationViewModel(appState: AppState()))
        }
    }
    
    var body: some View {
        let _ = viewModel.updateAppState(appState)
        
        NavigationView {
            Form {
                Section("Skill Level") {
                    Picker("Your Skill Level", selection: $viewModel.skillLevel) {
                        Text("Beginner").tag(Run.Difficulty.beginner)
                        Text("Intermediate").tag(Run.Difficulty.intermediate)
                        Text("Advanced").tag(Run.Difficulty.advanced)
                        Text("Expert").tag(Run.Difficulty.expert)
                    }
                }
                
                Section("Preferences") {
                    Toggle("Avoid Crowded Runs", isOn: $viewModel.avoidCrowds)
                    Toggle("Prefer Less Strenuous Routes", isOn: $viewModel.preferLessStrenuous)
                }
                
                if appState.selectedResort != nil {
                    Section("Start Navigation") {
                        Button("Choose Start & End Points") {
                            viewModel.showRouteSelection = true
                        }
                    }
                } else {
                    Section {
                        Text("Select a resort to start navigation")
                            .foregroundColor(.secondary)
                    }
                }
            }
            .navigationTitle("Navigation Setup")
            .sheet(isPresented: $viewModel.showRouteSelection) {
                if let resort = appState.selectedResort {
                    RouteSelectionView(resort: resort, viewModel: viewModel)
                }
            }
        }
    }
}

// MARK: - AR Resort View
struct ARResortView: View {
    @EnvironmentObject private var appState: AppState
    
    var body: some View {
        NavigationView {
            Group {
                if let resort = appState.selectedResort {
                    ContentUnavailableView(
                        "AR View Coming Soon",
                        systemImage: "camera.fill",
                        description: Text("AR features for \(resort.name) will be available in a future update.")
                    )
                } else {
                    ContentUnavailableView(
                        "No Resort Selected",
                        systemImage: "mountain.2",
                        description: Text("Select a resort to view AR features")
                    )
                }
            }
            .navigationTitle("AR View")
        }
    }
}

// MARK: - Supporting Views
struct ResortRowView: View {
    let resort: Resort
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text(resort.name)
                .font(.headline)
            
            HStack {
                StatusIndicator(
                    count: resort.lifts.filter { $0.status == .open }.count,
                    total: resort.lifts.count,
                    type: "Lifts"
                )
                
                Spacer()
                
                StatusIndicator(
                    count: resort.runs.filter { $0.status == .open }.count,
                    total: resort.runs.count,
                    type: "Runs"
                )
            }
            .padding(.top, 4)
        }
        .padding(.vertical, 8)
    }
}

struct StatusIndicator: View {
    let count: Int
    let total: Int
    let type: String
    
    var body: some View {
        HStack(spacing: 4) {
            Circle()
                .fill(count > 0 ? .green : .red)
                .frame(width: 8, height: 8)
            
            Text("\(count)/\(total) \(type)")
                .font(.caption)
                .foregroundColor(.secondary)
        }
    }
}

#Preview {
    ContentView()
        .environmentObject(AppState())
} 


### File: App/SkiTrails/Services/APIClient.swift
import Foundation
import CoreLocation
import SkiTrailsCore

enum APIError: Error {
    case invalidURL
    case invalidResponse
    case networkError(Error)
    case decodingError(Error)
    case serverError(Int)
    case unauthorized
    case unknown
    
    var localizedDescription: String {
        switch self {
        case .invalidURL:
            return "Invalid URL configuration"
        case .invalidResponse:
            return "Invalid server response"
        case .networkError(let error):
            return "Network error: \(error.localizedDescription)"
        case .decodingError(let error):
            return "Failed to decode response: \(error.localizedDescription)"
        case .serverError(let code):
            return "Server error with code: \(code)"
        case .unauthorized:
            return "Unauthorized access"
        case .unknown:
            return "An unknown error occurred"
        }
    }
}

actor APIClient {
    static let shared = APIClient()
    
    private let session: URLSession
    private let decoder: JSONDecoder
    private let encoder: JSONEncoder
    
    private init() {
        let configuration = URLSessionConfiguration.default
        configuration.timeoutIntervalForRequest = 30
        configuration.timeoutIntervalForResource = 300
        self.session = URLSession(configuration: configuration)
        
        self.decoder = JSONDecoder()
        self.decoder.keyDecodingStrategy = .convertFromSnakeCase
        self.decoder.dateDecodingStrategy = .iso8601
        
        self.encoder = JSONEncoder()
        self.encoder.keyEncodingStrategy = .convertToSnakeCase
        self.encoder.dateEncodingStrategy = .iso8601
    }
    
    func fetchResortList() async throws -> [Resort] {
        let url = try buildURL(path: "/resorts")
        return try await fetch(url)
    }
    
    func fetchWeather(for resort: Resort) async throws -> Weather {
        let url = try buildURL(path: "/weather/\(resort.id)")
        return try await fetch(url)
    }
    
    func fetchLiftStatus(for resort: Resort) async throws -> [Lift] {
        let url = try buildURL(path: "/lifts/\(resort.id)")
        return try await fetch(url)
    }
    
    func fetchResortInfo(id: String) async throws -> Resort {
        let url = try buildURL(path: "/resorts/\(id)")
        return try await fetch(url)
    }
    
    private func buildURL(path: String) throws -> URL {
        guard let baseURL = try? CoreConfig.getAPIBaseURL(),
              let url = URL(string: path, relativeTo: baseURL) else {
            throw APIError.invalidURL
        }
        return url
    }
    
    private func fetch<T: Decodable>(_ request: URLRequest) async throws -> T {
        do {
            let (data, response) = try await session.data(for: request)
            
            guard let httpResponse = response as? HTTPURLResponse else {
                throw APIError.invalidResponse
            }
            
            switch httpResponse.statusCode {
            case 200...299:
                do {
                    return try decoder.decode(T.self, from: data)
                } catch {
                    throw APIError.decodingError(error)
                }
            case 401:
                throw APIError.unauthorized
            case 400...499:
                throw APIError.invalidResponse
            case 500...599:
                throw APIError.serverError(httpResponse.statusCode)
            default:
                throw APIError.unknown
            }
        } catch is CancellationError {
            throw APIError.networkError(NSError(domain: "APIClient", code: -999, userInfo: [NSLocalizedDescriptionKey: "Request was cancelled"]))
        } catch {
            throw APIError.networkError(error)
        }
    }
    
    private func fetch<T: Decodable>(_ url: URL) async throws -> T {
        var request = URLRequest(url: url)
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        
        if let token = try? CoreConfig.getValue(for: "API_AUTH_TOKEN") {
            request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
        }
        
        return try await fetch(request)
    }
} 

### File: App/SkiTrails/Services/ErrorHandler.swift
import Foundation
import CoreLocation
import Sentry
import SkiTrailsCore

/// A service that handles error reporting and user-facing error messages
actor ErrorHandler {
    static let shared = ErrorHandler()
    
    private init() {}
    
    // MARK: - Error Handling
    
    func handle(_ error: Error, context: ErrorContext? = nil) {
        // Only send to Sentry in non-development environments
        if !EnvConfig.isDevelopment {
            let event = Event(level: .error)
            event.message = SentryMessage(formatted: error.localizedDescription)
            
            if let context = context {
                event.extra = context.contextData
                event.tags = ["context": context.name]
            }
            
            SentrySDK.capture(event: event)
        }
        
        // Log locally in debug mode
        #if DEBUG
        print("Error: \(error.localizedDescription)")
        if let context = context {
            print("Context: \(context.name)")
            print("Data: \(context.contextData)")
        }
        #endif
    }
    
    func handleUserFacing(_ error: Error, context: ErrorContext? = nil) -> UserFacingError {
        // Log the error
        handle(error, context: context)
        
        // Convert to user-facing error
        switch error {
        case let apiError as APIError:
            return UserFacingError(
                title: "Connection Error",
                message: apiError.localizedDescription,
                recoverySuggestion: apiError.recoverySuggestion
            )
        case let routingError as RoutingError:
            return UserFacingError(
                title: "Navigation Error",
                message: routingError.localizedDescription,
                recoverySuggestion: routingError.recoverySuggestion
            )
        case let locationError as CLError:
            return UserFacingError(
                title: "Location Error",
                message: locationError.localizedDescription,
                recoverySuggestion: "Please check your location permissions and try again."
            )
        default:
            return UserFacingError(
                title: "Error",
                message: error.localizedDescription,
                recoverySuggestion: "Please try again later."
            )
        }
    }
}

// MARK: - Supporting Types

/// Represents an error that can be shown to users
struct UserFacingError: LocalizedError {
    let title: String
    let message: String
    let recoverySuggestion: String?
    
    var errorDescription: String? { message }
}

/// Context information for error reporting
struct ErrorContext {
    let name: String
    let contextData: [String: Any]
    
    static func api(endpoint: String, parameters: [String: Any] = [:]) -> ErrorContext {
        ErrorContext(
            name: "API Error",
            contextData: [
                "endpoint": endpoint,
                "parameters": parameters
            ]
        )
    }
    
    static func navigation(
        start: CLLocationCoordinate2D,
        end: CLLocationCoordinate2D,
        preferences: RoutePreferences
    ) -> ErrorContext {
        ErrorContext(
            name: "Navigation Error",
            contextData: [
                "start": "\(start.latitude),\(start.longitude)",
                "end": "\(end.latitude),\(end.longitude)",
                "preferences": [
                    "avoidCrowds": preferences.avoidCrowds,
                    "preferLessStrenuous": preferences.preferLessStrenuous,
                    "maxWaitTime": preferences.maxWaitTime as Any
                ]
            ]
        )
    }
}

// MARK: - Error Extensions

extension APIError {
    var recoverySuggestion: String? {
        switch self {
        case .invalidURL:
            return "Please check your internet connection and try again."
        case .invalidResponse:
            return "The server returned an invalid response. Please try again later."
        case .networkError:
            return "Please check your internet connection and try again."
        case .decodingError:
            return "There was a problem processing the server response. Please try again later."
        case .serverError:
            return "The server is experiencing issues. Please try again later."
        case .unauthorized:
            return "Please sign in again to continue."
        case .unknown:
            return "Please try again later."
        }
    }
}

extension RoutingError {
    var recoverySuggestion: String? {
        switch self {
        case .graphNotInitialized:
            return "Please wait for the resort data to load and try again."
        case .noRouteFound:
            return "Try selecting different start and end points, or adjust your difficulty preferences."
        case .invalidPath:
            return "The selected route is no longer valid. Please try a different route."
        }
    }
} 

### File: App/SkiTrails/Services/LocationManager.swift
import CoreLocation
import Combine

final class LocationManager: NSObject, ObservableObject {
    private let manager = CLLocationManager()
    
    @Published var authorizationStatus: CLAuthorizationStatus
    @Published var currentLocation: CLLocation?
    
    override init() {
        authorizationStatus = manager.authorizationStatus
        super.init()
        manager.delegate = self
        manager.desiredAccuracy = kCLLocationAccuracyBest
        manager.distanceFilter = 5
        manager.activityType = .fitness
    }
    
    func requestAuthorization() {
        manager.requestWhenInUseAuthorization()
    }
    
    func startUpdatingLocation() {
        manager.startUpdatingLocation()
    }
    
    func stopUpdatingLocation() {
        manager.stopUpdatingLocation()
    }
}

extension LocationManager: CLLocationManagerDelegate {
    func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {
        authorizationStatus = status
    }
    
    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        guard let location = locations.last else { return }
        
        // Filter out old or inaccurate locations
        let locationAge = -location.timestamp.timeIntervalSinceNow
        guard locationAge < 5, // Less than 5 seconds old
              location.horizontalAccuracy >= 0,
              location.horizontalAccuracy < 50 // Accurate within 50 meters
        else {
            return
        }
        
        DispatchQueue.main.async {
            self.currentLocation = location
        }
    }
    
    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {
        print("Location manager failed with error: \(error.localizedDescription)")
    }
} 

### File: App/SkiTrails/Services/ResortDataService.swift
import Foundation
import MapboxMaps
import Combine

class ResortDataService: ObservableObject {
    @Published var boundaries: String?
    @Published var runs: String?
    @Published var lifts: String?
    @Published var isLoading = false
    @Published var error: Error?
    
    private let baseURL = "https://api.skiresort.com/v1" // Example API endpoint
    private var cancellables = Set<AnyCancellable>()
    
    func fetchResortData(resortId: String) {
        isLoading = true
        error = nil
        
        // Create API request
        let url = URL(string: "\(baseURL)/resorts/\(resortId)")!
        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        
        // Add API key if required
        if let apiKey = try? ResortConfig.getApiKey() {
            request.setValue(apiKey, forHTTPHeaderField: "X-API-Key")
        }
        
        // Make API request
        URLSession.shared.dataTaskPublisher(for: request)
            .map(\.data)
            .decode(type: ResortResponse.self, decoder: JSONDecoder())
            .receive(on: DispatchQueue.main)
            .sink { completion in
                self.isLoading = false
                if case .failure(let error) = completion {
                    self.error = error
                }
            } receiveValue: { response in
                self.boundaries = response.boundaries
                self.runs = response.runs
                self.lifts = response.lifts
            }
            .store(in: &cancellables)
    }
}

// Response models
struct ResortResponse: Codable {
    let boundaries: String // GeoJSON string
    let runs: String // GeoJSON string
    let lifts: String // GeoJSON string
}

// Configuration
enum ResortConfig {
    enum ConfigError: LocalizedError {
        case missingApiKey
        
        var errorDescription: String? {
            switch self {
            case .missingApiKey:
                return "Resort API key not found. Please set RESORT_API_KEY in your environment or Info.plist."
            }
        }
    }
    
    static func getApiKey() throws -> String {
        // First try environment variable
        if let key = ProcessInfo.processInfo.environment["RESORT_API_KEY"] {
            return key
        }
        
        // Then try Info.plist
        if let key = Bundle.main.object(forInfoDictionaryKey: "ResortApiKey") as? String {
            return key
        }
        
        throw ConfigError.missingApiKey
    }
} 

### File: Tests/SkiTrailsTests/SkiTrailsTests.swift
import XCTest
import CoreLocation
@testable import SkiTrailsCore

final class SkiTrailsTests: XCTestCase {
    var routingEngine: RoutingEngine!
    var testResort: Resort!
    
    override func setUp() async throws {
        routingEngine = RoutingEngine.shared
        testResort = createTestResort()
        await routingEngine.buildGraph(for: testResort)
    }
    
    func testRouteCalculation() async throws {
        let start = CLLocationCoordinate2D(latitude: 39.6403, longitude: -106.3742)
        let end = CLLocationCoordinate2D(latitude: 39.6500, longitude: -106.3800)
        
        let route = try await routingEngine.findRoute(
            from: start,
            to: end,
            difficulty: .intermediate
        )
        
        XCTAssertFalse(route.segments.isEmpty, "Route should contain segments")
        XCTAssertGreaterThan(route.totalDistance, 0, "Route should have positive distance")
        XCTAssertGreaterThan(route.estimatedTime, 0, "Route should have positive duration")
    }
    
    func testDifficultyFiltering() async throws {
        let start = CLLocationCoordinate2D(latitude: 39.6450, longitude: -106.3750)
        let end = CLLocationCoordinate2D(latitude: 39.6403, longitude: -106.3742)
        
        let beginnerRoute = try await routingEngine.findRoute(
            from: start,
            to: end,
            difficulty: .beginner
        )
        
        XCTAssertEqual(
            beginnerRoute.difficulty,
            .beginner,
            "Route difficulty should not exceed specified maximum"
        )
        
        for segment in beginnerRoute.segments {
            if case .run(let run) = segment.type {
                XCTAssertEqual(
                    run.difficulty,
                    .beginner,
                    "Run difficulty should not exceed beginner level"
                )
            }
        }
    }
    
    func testRoutePreferences() async throws {
        let start = CLLocationCoordinate2D(latitude: 39.6403, longitude: -106.3742)
        let end = CLLocationCoordinate2D(latitude: 39.6500, longitude: -106.3800)
        
        let preferences = RoutePreferences(
            avoidCrowds: true,
            preferLessStrenuous: true,
            maxWaitTime: 300
        )
        
        let route = try await routingEngine.findRoute(
            from: start,
            to: end,
            difficulty: .intermediate,
            preferences: preferences
        )
        
        for segment in route.segments {
            if case .lift(let lift) = segment.type {
                XCTAssertLessThanOrEqual(
                    lift.waitTime ?? 0,
                    preferences.maxWaitTime ?? .infinity,
                    "Lift wait time should not exceed maximum"
                )
            }
        }
    }
    
    // MARK: - Helper Methods
    
    private func createTestResort() -> Resort {
        let lifts = [
            Lift(
                id: UUID(),
                name: "Test Lift 1",
                status: .open,
                startLocation: Location(latitude: 39.6403, longitude: -106.3742, altitude: 2500),
                endLocation: Location(latitude: 39.6450, longitude: -106.3750, altitude: 3000),
                capacity: 4,
                waitTime: 300
            ),
            Lift(
                id: UUID(),
                name: "Test Lift 2",
                status: .open,
                startLocation: Location(latitude: 39.6450, longitude: -106.3750, altitude: 3000),
                endLocation: Location(latitude: 39.6500, longitude: -106.3800, altitude: 3500),
                capacity: 6,
                waitTime: 600
            )
        ]
        
        let runs = [
            Run(
                id: UUID(),
                name: "Easy Street",
                difficulty: .beginner,
                status: .open,
                startLocation: Location(latitude: 39.6450, longitude: -106.3750, altitude: 3000),
                endLocation: Location(latitude: 39.6403, longitude: -106.3742, altitude: 2500),
                length: 1000,
                verticalDrop: 500
            ),
            Run(
                id: UUID(),
                name: "Blue Heaven",
                difficulty: .intermediate,
                status: .open,
                startLocation: Location(latitude: 39.6500, longitude: -106.3800, altitude: 3500),
                endLocation: Location(latitude: 39.6450, longitude: -106.3750, altitude: 3000),
                length: 1500,
                verticalDrop: 500
            )
        ]
        
        return Resort(
            id: UUID(),
            name: "Test Resort",
            lifts: lifts,
            runs: runs
        )
    }
} 

### File: Sources/SkiTrails/ContentView.swift
import SwiftUI
import SkiTrailsCore

struct ContentView: View {
    @EnvironmentObject private var appState: AppState
    
    var body: some View {
        Text("Ski Trails")
            .padding()
            .overlay {
                if appState.isLoading {
                    ProgressView()
                }
            }
    }
}

#Preview {
    ContentView()
        .environmentObject(AppState())
}

### File: Sources/SkiTrails/Images.xcassets/Contents.json
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
} 

### File: Sources/SkiTrails/Images.xcassets/AppIcon.appiconset/Contents.json
{
  "images" : [
    {
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "20x20"
    },
    {
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "20x20"
    },
    {
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "29x29"
    },
    {
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "29x29"
    },
    {
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "40x40"
    },
    {
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "40x40"
    },
    {
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "60x60"
    },
    {
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "60x60"
    },
    {
      "idiom" : "ios-marketing",
      "scale" : "1x",
      "size" : "1024x1024"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
} 

### File: Sources/SkiTrailsCore/SkiTrailsCore.swift
@_exported import Foundation
@_exported import SwiftUI

// No type aliases - use CoreState and CoreConfig directly 

### File: Sources/SkiTrailsCore/ViewModels/MapViewModel.swift
import SwiftUI
import CoreLocation

public class MapViewModel: ObservableObject {
    @Published public var selectedFeature: MapFeature?
    
    public let defaultCenter = CLLocationCoordinate2D(latitude: 39.6403, longitude: -106.3742) // Vail, CO
    public let defaultZoom = 14.0
    public let defaultPitch = 45.0
    public let defaultBearing = 0.0
    
    public init() {}
} 

### File: Sources/SkiTrailsCore/Configuration/Configuration.swift
import Foundation

public struct Configuration {
    public let apiBaseURL: URL
    public let apiKey: String
    
    public init() throws {
        self.apiBaseURL = try CoreConfig.getAPIBaseURL()
        self.apiKey = try CoreConfig.getValue(for: "API_AUTH_TOKEN")
    }
    
    public static func `default`() throws -> Configuration {
        try Configuration()
    }
}

extension Configuration {
    public enum Error: Swift.Error, LocalizedError {
        case invalidURL
        case missingAPIKey
        
        public var errorDescription: String? {
            switch self {
            case .invalidURL:
                return "Invalid API base URL format"
            case .missingAPIKey:
                return "Missing API authentication key"
            }
        }
    }
} 

### File: Sources/SkiTrailsCore/Configuration/CoreConfig.swift
import Foundation
import SwiftUI

// MARK: - Core Configuration
public enum CoreConfig {
    public enum Error: Swift.Error, LocalizedError {
        case missingKey(String)
        case invalidURLFormat(String)
        
        public var errorDescription: String? {
            switch self {
            case .missingKey(let key):
                return "Missing required environment variable: \(key)"
            case .invalidURLFormat(let url):
                return "Invalid URL format: \(url)"
            }
        }
    }
    
    public static func getValue(for key: String) throws -> String {
        guard let value = ProcessInfo.processInfo.environment[key], !value.isEmpty else {
            throw Error.missingKey(key)
        }
        return value
    }
    
    public static func getDSN() throws -> String {
        try getValue(for: "SENTRY_DSN")
    }
    
    public static func getMapboxAccessToken() throws -> String {
        try getValue(for: "MAPBOX_ACCESS_TOKEN")
    }
    
    public static func getWeatherAPIKey() throws -> String {
        try getValue(for: "WEATHER_UNLOCKED_API_KEY")
    }
    
    public static func getWeatherAppID() throws -> String {
        try getValue(for: "WEATHER_UNLOCKED_APP_ID")
    }
    
    public static func getLiftieAPIBaseURL() throws -> String {
        try getValue(for: "LIFTIE_API_BASE_URL")
    }
    
    public static func getLiftieResortList() throws -> [String] {
        let list = try getValue(for: "LIFTIE_RESORT_LIST")
        return list.split(separator: ",").map(String.init)
    }
    
    public static func getAPIBaseURL() throws -> URL {
        let urlString = try getValue(for: "API_BASE_URL")
        guard let url = URL(string: urlString) else {
            throw Error.invalidURLFormat(urlString)
        }
        return url
    }
}

// MARK: - Core State Management
public protocol CoreStateManaging: ObservableObject {
    var selectedResort: Resort? { get }
    var isLoading: Bool { get }
    var error: Error? { get }
    
    func selectResort(_ resort: Resort)
    func setError(_ error: Error)
    func setLoading(_ loading: Bool)
}

public final class CoreState: CoreStateManaging {
    @Published public private(set) var selectedResort: Resort?
    @Published public private(set) var isLoading = false
    @Published public private(set) var error: Error?
    
    public init() {}
    
    public func selectResort(_ resort: Resort) {
        selectedResort = resort
    }
    
    public func setError(_ error: Error) {
        self.error = error
    }
    
    public func setLoading(_ loading: Bool) {
        isLoading = loading
    }
} 

### File: Sources/SkiTrailsCore/Configuration/MapConfig.swift
import Foundation

public enum MapConfig {
    public enum Error: Swift.Error, LocalizedError {
        case missingMapboxToken
        
        public var errorDescription: String? {
            switch self {
            case .missingMapboxToken:
                return "Missing Mapbox access token"
            }
        }
    }
    
    public static func getMapboxAccessToken() throws -> String {
        try CoreConfig.getMapboxAccessToken()
    }
} 

### File: Sources/SkiTrailsCore/Models/AppState.swift
import Foundation
import SwiftUI
import CoreLocation

public class AppState: ObservableObject {
    @Published public var isLoading: Bool = false
    @Published public var selectedTrail: String? = nil
    @Published public var navigationActive: Bool = false
    @Published public var error: Error?
    @Published public private(set) var resorts: [Resort] = []
    @Published public private(set) var selectedResort: Resort?
    @Published public var selectedDestination: Location?
    @Published public var currentLocation: CLLocation?
    
    private let apiClient: APIClient
    public let configuration: Configuration?
    
    public init() {
        self.apiClient = .shared
        do {
            self.configuration = try Configuration.default()
        } catch {
            self.configuration = nil
            self.error = error
        }
    }
    
    public init(configuration: Configuration) {
        self.apiClient = .shared
        self.configuration = configuration
    }
    
    @MainActor
    public func loadResorts() async {
        isLoading = true
        do {
            let resortList = try await apiClient.fetchResortList()
            self.resorts = resortList
            isLoading = false
        } catch {
            self.error = error
            isLoading = false
        }
    }
    
    @MainActor
    public func selectResort(_ resort: Resort) {
        selectedResort = resort
    }
} 

### File: Sources/SkiTrailsCore/Models/HeavenlyData.swift
import Foundation

public enum HeavenlyData {
    public static let runs = """
    {
      "type": "FeatureCollection",
      "features": [
        {
          "type": "Feature",
          "properties": {
            "name": "Orion",
            "difficulty": "blue",
            "status": "open"
          },
          "geometry": {
            "type": "Polygon",
            "coordinates": [[
              [-119.939, 38.935],
              [-119.938, 38.934],
              [-119.937, 38.933],
              [-119.938, 38.932],
              [-119.939, 38.935]
            ]]
          }
        },
        {
          "type": "Feature",
          "properties": {
            "name": "Comet",
            "difficulty": "black",
            "status": "open"
          },
          "geometry": {
            "type": "Polygon",
            "coordinates": [[
              [-119.940, 38.936],
              [-119.939, 38.935],
              [-119.938, 38.934],
              [-119.939, 38.933],
              [-119.940, 38.936]
            ]]
          }
        },
        {
          "type": "Feature",
          "properties": {
            "name": "Big Dipper",
            "difficulty": "blue",
            "status": "open"
          },
          "geometry": {
            "type": "Polygon",
            "coordinates": [[
              [-119.941, 38.937],
              [-119.940, 38.936],
              [-119.939, 38.935],
              [-119.940, 38.934],
              [-119.941, 38.937]
            ]]
          }
        }
      ]
    }
    """
    
    public static let lifts = """
    {
      "type": "FeatureCollection",
      "features": [
        {
          "type": "Feature",
          "properties": {
            "name": "Heavenly Gondola",
            "type": "gondola",
            "status": "open"
          },
          "geometry": {
            "type": "LineString",
            "coordinates": [
              [-119.939, 38.935],
              [-119.938, 38.934],
              [-119.937, 38.933]
            ]
          }
        },
        {
          "type": "Feature",
          "properties": {
            "name": "Comet Express",
            "type": "chairlift",
            "status": "open"
          },
          "geometry": {
            "type": "LineString",
            "coordinates": [
              [-119.940, 38.936],
              [-119.939, 38.935],
              [-119.938, 38.934]
            ]
          }
        },
        {
          "type": "Feature",
          "properties": {
            "name": "Dipper Express",
            "type": "chairlift",
            "status": "open"
          },
          "geometry": {
            "type": "LineString",
            "coordinates": [
              [-119.941, 38.937],
              [-119.940, 38.936],
              [-119.939, 38.935]
            ]
          }
        }
      ]
    }
    """
    
    public static let boundaries = """
    {
      "type": "FeatureCollection",
      "features": [
        {
          "type": "Feature",
          "properties": {
            "name": "Heavenly Resort Boundary"
          },
          "geometry": {
            "type": "Polygon",
            "coordinates": [[
              [-119.942, 38.938],
              [-119.936, 38.938],
              [-119.936, 38.932],
              [-119.942, 38.932],
              [-119.942, 38.938]
            ]]
          }
        }
      ]
    }
    """
} 

### File: Sources/SkiTrailsCore/Models/MapFeature.swift
import Foundation

public enum MapFeature {
    case run(Run)
    case lift(Lift)
    case point(name: String, latitude: Double, longitude: Double)
    
    public var name: String {
        switch self {
        case .run(let run):
            return run.name
        case .lift(let lift):
            return lift.name
        case .point(let name, _, _):
            return name
        }
    }
    
    public var coordinates: (latitude: Double, longitude: Double) {
        switch self {
        case .run(let run):
            return (run.startLocation.latitude, run.startLocation.longitude)
        case .lift(let lift):
            return (lift.startLocation.latitude, lift.startLocation.longitude)
        case .point(_, let latitude, let longitude):
            return (latitude, longitude)
        }
    }
} 

### File: Sources/SkiTrailsCore/Models/Resort.swift
import Foundation

public struct EntityID: Codable, Hashable, Identifiable {
    public let rawValue: String
    public var id: String { rawValue }
    
    public init(_ uuid: UUID) {
        self.rawValue = uuid.uuidString
    }
    
    public init(_ string: String) {
        self.rawValue = string
    }
    
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.rawValue = value
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(rawValue)
    }
}

public struct Resort: Identifiable, Codable {
    public let id: EntityID
    public let name: String
    public let lifts: [Lift]
    public let runs: [Run]
    
    public init(id: EntityID, name: String, lifts: [Lift], runs: [Run]) {
        self.id = id
        self.name = name
        self.lifts = lifts
        self.runs = runs
    }
    
    public static var preview: Resort {
        let lifts = [
            Lift(
                id: EntityID(UUID()),
                name: "Express Lift",
                status: .open,
                startLocation: Location(latitude: 39.6450, longitude: -106.3750, altitude: 3000),
                endLocation: Location(latitude: 39.6500, longitude: -106.3800, altitude: 3500),
                capacity: 6,
                waitTime: 600
            )
        ]
        
        let runs = [
            Run(
                id: EntityID(UUID()),
                name: "Easy Street",
                difficulty: .beginner,
                status: .open,
                startLocation: Location(latitude: 39.6450, longitude: -106.3750, altitude: 3000),
                endLocation: Location(latitude: 39.6403, longitude: -106.3742, altitude: 2500),
                length: 1000,
                verticalDrop: 500
            ),
            Run(
                id: EntityID(UUID()),
                name: "Blue Heaven",
                difficulty: .intermediate,
                status: .open,
                startLocation: Location(latitude: 39.6500, longitude: -106.3800, altitude: 3500),
                endLocation: Location(latitude: 39.6450, longitude: -106.3750, altitude: 3000),
                length: 1500,
                verticalDrop: 500
            )
        ]
        
        return Resort(
            id: EntityID(UUID()),
            name: "Test Resort",
            lifts: lifts,
            runs: runs
        )
    }
}

public struct Lift: Identifiable, Codable {
    public let id: EntityID
    public let name: String
    public let status: Status
    public let startLocation: Location
    public let endLocation: Location
    public let capacity: Int
    public let waitTime: TimeInterval?
    
    public enum Status: String, Codable {
        case open, closed, onHold, maintenance
    }
    
    public init(id: EntityID, name: String, status: Status, startLocation: Location, endLocation: Location, capacity: Int, waitTime: TimeInterval? = nil) {
        self.id = id
        self.name = name
        self.status = status
        self.startLocation = startLocation
        self.endLocation = endLocation
        self.capacity = capacity
        self.waitTime = waitTime
    }
}

public struct Run: Identifiable, Codable, Hashable {
    public let id: EntityID
    public let name: String
    public let difficulty: Difficulty
    public let status: Status
    public let startLocation: Location
    public let endLocation: Location
    public let length: Double
    public let verticalDrop: Double
    
    public enum Difficulty: String, Codable, CaseIterable, Comparable {
        case beginner, intermediate, advanced, expert
        
        public static func < (lhs: Difficulty, rhs: Difficulty) -> Bool {
            let order: [Difficulty] = [.beginner, .intermediate, .advanced, .expert]
            guard let lhsIndex = order.firstIndex(of: lhs),
                  let rhsIndex = order.firstIndex(of: rhs) else {
                return false
            }
            return lhsIndex < rhsIndex
        }
        
        public var color: String {
            switch self {
            case .beginner: return "green"
            case .intermediate: return "blue"
            case .advanced: return "black"
            case .expert: return "doubleBlack"
            }
        }
    }
    
    public enum Status: String, Codable {
        case open, closed, grooming
    }
    
    public init(id: EntityID, name: String, difficulty: Difficulty, status: Status, startLocation: Location, endLocation: Location, length: Double, verticalDrop: Double) {
        self.id = id
        self.name = name
        self.difficulty = difficulty
        self.status = status
        self.startLocation = startLocation
        self.endLocation = endLocation
        self.length = length
        self.verticalDrop = verticalDrop
    }
    
    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
    
    public static func == (lhs: Run, rhs: Run) -> Bool {
        lhs.id == rhs.id
    }
}

public struct Location: Equatable, Hashable, Codable {
    public let latitude: Double
    public let longitude: Double
    public let altitude: Double
    
    public init(latitude: Double, longitude: Double, altitude: Double) {
        self.latitude = latitude
        self.longitude = longitude
        self.altitude = altitude
    }
}

public struct Weather: Codable {
    public let temperature: Double
    public let conditions: String
    public let snowDepth: Double
    public let windSpeed: Double
    public let visibility: Double
    
    public init(temperature: Double, conditions: String, snowDepth: Double, windSpeed: Double, visibility: Double) {
        self.temperature = temperature
        self.conditions = conditions
        self.snowDepth = snowDepth
        self.windSpeed = windSpeed
        self.visibility = visibility
    }
} 

### File: Sources/SkiTrailsCore/Models/Status.swift
import SwiftUI

public enum Status: String, Codable {
    case open
    case closed
    case hold
    case scheduled
    case grooming
    
    public var color: Color {
        switch self {
        case .open: return .green
        case .closed: return .red
        case .hold: return .orange
        case .scheduled: return .blue
        case .grooming: return .purple
        }
    }
} 

### File: Sources/SkiTrailsCore/Routing/RoutingEngine.swift
import Foundation
import CoreLocation

public actor RoutingEngine {
    public static let shared = RoutingEngine()
    private var resortGraph: ResortGraph?
    
    private init() {}
    
    // MARK: - Graph Management
    
    public func buildGraph(for resort: Resort) {
        let nodes = buildNodes(from: resort)
        let edges = buildEdges(from: resort)
        resortGraph = ResortGraph(nodes: nodes, edges: edges)
    }
    
    public func findRoute(
        from start: CLLocationCoordinate2D,
        to end: CLLocationCoordinate2D,
        difficulty: SkiDifficulty = .intermediate,
        preferences: RoutePreferences = RoutePreferences()
    ) async throws -> Route {
        guard let graph = resortGraph else {
            throw RoutingError.graphNotInitialized
        }
        
        let startNode = try findNearestNode(to: start, in: graph)
        let endNode = try findNearestNode(to: end, in: graph)
        
        let path = try findPath(
            from: startNode,
            to: endNode,
            in: graph,
            maxDifficulty: difficulty,
            preferences: preferences
        )
        return try buildRoute(from: path, in: graph)
    }
    
    // MARK: - Private Methods
    
    private func buildNodes(from resort: Resort) -> [String: Node] {
        var nodes: [String: Node] = [:]
        
        // Add lift nodes
        for lift in resort.lifts {
            // Add lift base node
            nodes[lift.id.rawValue] = Node(
                id: lift.id.rawValue,
                coordinate: CLLocationCoordinate2D(latitude: lift.startLocation.latitude, longitude: lift.startLocation.longitude),
                elevation: lift.startLocation.altitude,
                type: .lift(lift)
            )
            
            // Add lift top node
            let topNodeId = "\(lift.id.rawValue)_top"
            nodes[topNodeId] = Node(
                id: topNodeId,
                coordinate: CLLocationCoordinate2D(latitude: lift.endLocation.latitude, longitude: lift.endLocation.longitude),
                elevation: lift.endLocation.altitude,
                type: .lift(lift)
            )
        }
        
        // Add run nodes
        for run in resort.runs {
            // Add top node for the run
            let topNodeId = "\(run.id.rawValue)_top"
            nodes[topNodeId] = Node(
                id: topNodeId,
                coordinate: CLLocationCoordinate2D(latitude: run.startLocation.latitude, longitude: run.startLocation.longitude),
                elevation: run.startLocation.altitude,
                type: .run(run)
            )
            
            // Add bottom node for the run
            let bottomNodeId = "\(run.id.rawValue)_bottom"
            nodes[bottomNodeId] = Node(
                id: bottomNodeId,
                coordinate: CLLocationCoordinate2D(latitude: run.endLocation.latitude, longitude: run.endLocation.longitude),
                elevation: run.endLocation.altitude,
                type: .run(run)
            )
        }
        
        return nodes
    }
    
    private func buildEdges(from resort: Resort) -> [Edge] {
        var edges: [Edge] = []
        let connectionThreshold: Double = 500 // 500m connection threshold
        
        // Connect lift bases to lift tops
        for lift in resort.lifts {
            if lift.status != .open {
                continue
            }
            
            // Connect lift base to lift top
            edges.append(Edge(
                from: lift.id.rawValue,
                to: "\(lift.id.rawValue)_top",
                type: .lift,
                distance: lift.endLocation.altitude - lift.startLocation.altitude
            ))
        }
        
        // Connect lift tops to nearby run tops and other lift bases
        for lift in resort.lifts {
            if lift.status != .open {
                continue
            }
            
            let liftTopLocation = CLLocation(
                latitude: lift.endLocation.latitude,
                longitude: lift.endLocation.longitude
            )
            
            // Connect to run tops
            for run in resort.runs {
                if run.status != .open {
                    continue
                }
                
                let runTopLocation = CLLocation(
                    latitude: run.startLocation.latitude,
                    longitude: run.startLocation.longitude
                )
                
                let distance = liftTopLocation.distance(from: runTopLocation)
                if distance < connectionThreshold {
                    edges.append(Edge(
                        from: "\(lift.id.rawValue)_top",
                        to: "\(run.id.rawValue)_top",
                        type: .connection,
                        distance: distance
                    ))
                }
            }
            
            // Connect to other lift bases
            for otherLift in resort.lifts {
                if otherLift.id == lift.id || otherLift.status != .open {
                    continue
                }
                
                let otherLiftBaseLocation = CLLocation(
                    latitude: otherLift.startLocation.latitude,
                    longitude: otherLift.startLocation.longitude
                )
                
                let distance = liftTopLocation.distance(from: otherLiftBaseLocation)
                if distance < connectionThreshold {
                    edges.append(Edge(
                        from: "\(lift.id.rawValue)_top",
                        to: otherLift.id.rawValue,
                        type: .connection,
                        distance: distance
                    ))
                }
            }
        }
        
        // Connect run tops to run bottoms
        for run in resort.runs {
            if run.status != .open {
                continue
            }
            
            edges.append(Edge(
                from: "\(run.id.rawValue)_top",
                to: "\(run.id.rawValue)_bottom",
                type: .run(difficulty: run.difficulty),
                distance: run.length
            ))
        }
        
        // Connect run bottoms to lift bases
        for run in resort.runs {
            if run.status != .open {
                continue
            }
            
            let runBottomLocation = CLLocation(
                latitude: run.endLocation.latitude,
                longitude: run.endLocation.longitude
            )
            
            for lift in resort.lifts {
                if lift.status != .open {
                    continue
                }
                
                let liftBaseLocation = CLLocation(
                    latitude: lift.startLocation.latitude,
                    longitude: lift.startLocation.longitude
                )
                
                let distance = runBottomLocation.distance(from: liftBaseLocation)
                if distance < connectionThreshold {
                    edges.append(Edge(
                        from: "\(run.id.rawValue)_bottom",
                        to: lift.id.rawValue,
                        type: .connection,
                        distance: distance
                    ))
                }
            }
        }
        
        return edges
    }
    
    private func findNearestNode(to coordinate: CLLocationCoordinate2D, in graph: ResortGraph) throws -> Node {
        let location = CLLocation(latitude: coordinate.latitude, longitude: coordinate.longitude)
        
        guard let nearest = graph.nodes.values.min(by: { a, b in
            let aLocation = CLLocation(
                latitude: a.coordinate.latitude,
                longitude: a.coordinate.longitude
            )
            let bLocation = CLLocation(
                latitude: b.coordinate.latitude, longitude)
            
            return location.distance(from: aLocation) < location.distance(from: bLocation)
        }) else {
            throw RoutingError.noRouteFound
        }
        
        return nearest
    }
    
    private func findPath(
        from start: Node,
        to end: Node,
        in graph: ResortGraph,
        maxDifficulty: SkiDifficulty,
        preferences: RoutePreferences
    ) throws -> [String] {
        var openSet = Set<String>([start.id])
        var closedSet = Set<String>()
        
        var cameFrom: [String: String] = [:]
        var gScore: [String: Double] = [start.id: 0]
        var fScore: [String: Double] = [start.id: heuristic(from: start, to: end)]
        
        while !openSet.isEmpty {
            let current = openSet.min { a, b in
                (fScore[a] ?? .infinity) < (fScore[b] ?? .infinity)
            }!
            
            if current == end.id {
                return reconstructPath(cameFrom: cameFrom, current: current)
            }
            
            openSet.remove(current)
            closedSet.insert(current)
            
            let edges = graph.edges.filter { $0.from == current }
            for edge in edges {
                guard !closedSet.contains(edge.to),
                      let node = graph.nodes[edge.to] else {
                    continue
                }
                
                // Skip if difficulty is too high
                if case .run(let run) = node.type,
                   !isRunAllowed(run, maxDifficulty: maxDifficulty) {
                    continue
                }
                
                let tentativeGScore = (gScore[current] ?? .infinity) + calculateEdgeWeight(edge, node: node, preferences: preferences)
                
                if !openSet.contains(edge.to) {
                    openSet.insert(edge.to)
                } else if tentativeGScore >= (gScore[edge.to] ?? .infinity) {
                    continue
                }
                
                cameFrom[edge.to] = current
                gScore[edge.to] = tentativeGScore
                fScore[edge.to] = tentativeGScore + heuristic(from: node, to: end)
            }
        }
        
        throw RoutingError.noRouteFound
    }
    
    private func calculateEdgeWeight(_ edge: Edge, node: Node, preferences: RoutePreferences) -> Double {
        var weight = edge.distance
        
        switch edge.type {
        case .lift:
            if preferences.avoidCrowds,
               case .lift(let lift) = node.type,
               let waitTime = lift.waitTime,
               waitTime > (preferences.maxWaitTime ?? 15) {
                // Apply significant penalty for crowded lifts
                weight *= 2.5
            }
            
        case .run:
            if preferences.preferLessStrenuous {
                // Apply penalty based on run length and elevation change
                let elevationPenalty = abs(node.elevation) * 0.5
                weight = weight * (1 + elevationPenalty/1000)
            }
            
        case .connection:
            // Apply small penalty to walking connections if preferring less strenuous routes
            if preferences.preferLessStrenuous {
                weight *= 1.2
            }
        }
        
        return weight
    }
    
    private func reconstructPath(cameFrom: [String: String], current: String) -> [String] {
        var path = [current]
        var currentNode = current
        
        while let previous = cameFrom[currentNode] {
            path.insert(previous, at: 0)
            currentNode = previous
        }
        
        return path
    }
    
    private func buildRoute(from path: [String], in graph: ResortGraph) throws -> Route {
        var segments: [Route.Segment] = []
        var totalDistance: Double = 0
        var maxDifficulty: SkiDifficulty = .beginner
        
        for i in 0..<(path.count - 1) {
            let fromId = path[i]
            let toId = path[i + 1]
            
            guard let fromNode = graph.nodes[fromId],
                  let toNode = graph.nodes[toId],
                  let edge = graph.edges.first(where: { $0.from == fromId && $0.to == toId }) else {
                throw RoutingError.invalidPath
            }
            
            let segment = try buildSegment(
                from: fromNode,
                to: toNode,
                edge: edge
            )
            
            segments.append(segment)
            totalDistance += segment.distance
            
            if case .run(let run) = segment.type {
                maxDifficulty = max(maxDifficulty, run.difficulty)
            }
        }
        
        return Route(
            segments: segments,
            totalDistance: totalDistance,
            estimatedTime: calculateEstimatedTime(for: segments),
            difficulty: maxDifficulty
        )
    }
    
    private func heuristic(from: Node, to: Node) -> Double {
        let fromLocation = CLLocation(
            latitude: from.coordinate.latitude,
            longitude: from.coordinate.longitude
        )
        let toLocation = CLLocation(
            latitude: to.coordinate.latitude,
            longitude: to.coordinate.longitude
        )
        
        return fromLocation.distance(from: toLocation)
    }
    
    private func isRunAllowed(_ run: Run, maxDifficulty: SkiDifficulty) -> Bool {
        switch (run.difficulty, maxDifficulty) {
        case (.beginner, _):
            return true
        case (.intermediate, .intermediate), (.intermediate, .advanced), (.intermediate, .expert):
            return true
        case (.advanced, .advanced), (.advanced, .expert):
            return true
        case (.expert, .expert):
            return true
        default:
            return false
        }
    }
    
    private func calculateEstimatedTime(for segments: [Route.Segment]) -> TimeInterval {
        segments.reduce(0) { total, segment in
            switch segment.type {
            case .run:
                // Assume average speed of 20 km/h on runs
                return total + (segment.distance / 5.56) // 5.56 m/s = 20 km/h
            case .lift:
                // Assume average lift speed of 5 m/s
                return total + (segment.distance / 5.0)
            case .connection:
                // Assume walking speed of 1.4 m/s
                return total + (segment.distance / 1.4)
            }
        }
    }
    
    private func buildSegment(
        from: Node,
        to: Node,
        edge: Edge
    ) throws -> Route.Segment {
        let type: Route.Segment.SegmentType
        
        switch (from.type, to.type) {
        case (.lift(let lift), _):
            type = .lift(lift)
        case (.run(let run), _):
            type = .run(run)
        default:
            type = .connection
        }
        
        return Route.Segment(
            type: type,
            path: [
                Route.Segment.Location(
                    latitude: from.coordinate.latitude,
                    longitude: from.coordinate.longitude,
                    altitude: from.elevation
                ),
                Route.Segment.Location(
                    latitude: to.coordinate.latitude,
                    longitude: to.coordinate.longitude,
                    altitude: to.elevation
                )
            ],
            distance: edge.distance
        )
    }
}

// MARK: - Supporting Types

public struct ResortGraph {
    let nodes: [String: Node]
    let edges: [Edge]
}

public struct Node {
    let id: String
    let coordinate: CLLocationCoordinate2D
    let elevation: Double
    let type: NodeType
    
    init(id: String, coordinate: CLLocationCoordinate2D, elevation: Double, type: NodeType = .point) {
        self.id = id
        self.coordinate = coordinate
        self.elevation = elevation
        self.type = type
    }
}

public enum NodeType {
    case lift(Lift)
    case run(Run)
    case point
}

public struct Edge {
    let from: String
    let to: String
    let type: EdgeType
    let distance: Double
    
    enum EdgeType {
        case run(difficulty: SkiDifficulty)
        case lift
        case connection
    }
}

public struct RoutePreferences {
    public let avoidCrowds: Bool
    public let preferLessStrenuous: Bool
    public let maxWaitTime: TimeInterval?
    
    public init(avoidCrowds: Bool = false, preferLessStrenuous: Bool = false, maxWaitTime: TimeInterval? = nil) {
        self.avoidCrowds = avoidCrowds
        self.preferLessStrenuous = preferLessStrenuous
        self.maxWaitTime = maxWaitTime
    }
}

public enum RoutingError: Error {
    case graphNotInitialized
    case noRouteFound
    case invalidPath
} 


### File: Sources/SkiTrailsCore/Routing/RoutingTypes.swift
import Foundation
import CoreLocation

public typealias SkiDifficulty = Run.Difficulty

public struct Route {
    public let segments: [Segment]
    public let totalDistance: Double
    public let estimatedTime: TimeInterval
    public let difficulty: SkiDifficulty
    
    public struct Segment {
        public let type: SegmentType
        public let path: [Location]
        public let distance: Double
        
        public enum SegmentType {
            case run(Run)
            case lift(Lift)
            case connection
        }
        
        public struct Location {
            public let latitude: Double
            public let longitude: Double
            public let altitude: Double
            
            public init(latitude: Double, longitude: Double, altitude: Double) {
                self.latitude = latitude
                self.longitude = longitude
                self.altitude = altitude
            }
        }
        
        public init(type: SegmentType, path: [Location], distance: Double) {
            self.type = type
            self.path = path
            self.distance = distance
        }
    }
    
    public init(segments: [Segment], totalDistance: Double, estimatedTime: TimeInterval, difficulty: SkiDifficulty) {
        self.segments = segments
        self.totalDistance = totalDistance
        self.estimatedTime = estimatedTime
        self.difficulty = difficulty
    }
} 

### File: Sources/SkiTrailsCore/Services/APIClient.swift
import Foundation
import CoreLocation

public enum APIError: Error, LocalizedError {
    case invalidURL
    case invalidResponse
    case networkError(Error)
    case decodingError(Error)
    case serverError(Int)
    case unauthorized
    case unknown
    
    public var errorDescription: String? {
        switch self {
        case .invalidURL:
            return "Invalid URL configuration"
        case .invalidResponse:
            return "Invalid server response"
        case .networkError(let error):
            return "Network error: \(error.localizedDescription)"
        case .decodingError(let error):
            return "Failed to decode response: \(error.localizedDescription)"
        case .serverError(let code):
            return "Server error with code: \(code)"
        case .unauthorized:
            return "Unauthorized access"
        case .unknown:
            return "An unknown error occurred"
        }
    }
}

public actor APIClient {
    public static let shared = APIClient()
    
    private let session: URLSession
    private let decoder: JSONDecoder
    private let encoder: JSONEncoder
    
    private init() {
        let configuration = URLSessionConfiguration.default
        configuration.timeoutIntervalForRequest = 30
        configuration.timeoutIntervalForResource = 300
        self.session = URLSession(configuration: configuration)
        
        self.decoder = JSONDecoder()
        self.decoder.keyDecodingStrategy = .convertFromSnakeCase
        self.decoder.dateDecodingStrategy = .iso8601
        
        self.encoder = JSONEncoder()
        self.encoder.keyEncodingStrategy = .convertToSnakeCase
        self.encoder.dateEncodingStrategy = .iso8601
    }
    
    public func fetchResortList() async throws -> [Resort] {
        let url = try buildURL(path: "/resorts")
        return try await fetch(url)
    }
    
    public func fetchWeather(for resort: Resort) async throws -> WeatherInfo {
        let url = try buildURL(path: "/weather/\(resort.id)")
        return try await fetch(url)
    }
    
    public func fetchLiftStatus(for resort: Resort) async throws -> [Lift] {
        let url = try buildURL(path: "/lifts/\(resort.id)")
        return try await fetch(url)
    }
    
    public func fetchResortInfo(id: String) async throws -> Resort {
        let url = try buildURL(path: "/resorts/\(id)")
        return try await fetch(url)
    }
    
    private func buildURL(path: String) throws -> URL {
        guard let baseURL = try? CoreConfig.getAPIBaseURL(),
              let url = URL(string: path, relativeTo: baseURL) else {
            throw APIError.invalidURL
        }
        return url
    }
    
    private func fetch<T: Decodable>(_ request: URLRequest) async throws -> T {
        do {
            let (data, response) = try await session.data(for: request)
            
            guard let httpResponse = response as? HTTPURLResponse else {
                throw APIError.invalidResponse
            }
            
            switch httpResponse.statusCode {
            case 200...299:
                do {
                    return try decoder.decode(T.self, from: data)
                } catch {
                    throw APIError.decodingError(error)
                }
            case 401:
                throw APIError.unauthorized
            case 400...499:
                throw APIError.invalidResponse
            case 500...599:
                throw APIError.serverError(httpResponse.statusCode)
            default:
                throw APIError.unknown
            }
        } catch is CancellationError {
            throw APIError.networkError(NSError(domain: "APIClient", code: -999, userInfo: [NSLocalizedDescriptionKey: "Request was cancelled"]))
        } catch {
            throw APIError.networkError(error)
        }
    }
    
    private func fetch<T: Decodable>(_ url: URL) async throws -> T {
        var request = URLRequest(url: url)
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        
        if let token = try? CoreConfig.getValue(for: "API_AUTH_TOKEN") {
            request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
        }
        
        return try await fetch(request)
    }
}

public struct WeatherInfo: Codable {
    public let temperature: Double
    public let conditions: String
    public let snowDepth: Double
    public let windSpeed: Double
    public let visibility: Double
    
    public init(temperature: Double, conditions: String, snowDepth: Double, windSpeed: Double, visibility: Double) {
        self.temperature = temperature
        self.conditions = conditions
        self.snowDepth = snowDepth
        self.windSpeed = windSpeed
        self.visibility = visibility
    }
} 

### File: SkiTrailsCore/Package.swift
// swift-tools-version: 5.9
import PackageDescription

let package = Package(
    name: "SkiTrailsCore",
    platforms: [
        .iOS(.v17)
    ],
    products: [
        .library(
            name: "SkiTrailsCore",
            targets: ["SkiTrailsCore"]),
    ],
    dependencies: [
        .package(url: "https://github.com/mapbox/mapbox-maps-ios.git", .upToNextMajor(from: "10.16.0")),
        .package(url: "https://github.com/mapbox/turf-swift.git", exact: "2.8.0")
    ],
    targets: [
        .target(
            name: "SkiTrailsCore",
            dependencies: [
                .product(name: "MapboxMaps", package: "mapbox-maps-ios"),
                .product(name: "Turf", package: "turf-swift")
            ]),
        .testTarget(
            name: "SkiTrailsCoreTests",
            dependencies: ["SkiTrailsCore"]),
    ]
) 

### File: SkiTrailsCore/Sources/SkiTrailsCore/ViewModels/MapViewModel.swift
import Foundation
import MapboxMaps

public class MapViewModel: ObservableObject {
    @Published public var camera: CameraOptions
    
    public init(camera: CameraOptions = MapConfig.defaultCamera) {
        self.camera = camera
    }
} 

### File: SkiTrailsCore/Sources/SkiTrailsCore/Configuration/Configuration.swift
import Foundation

public protocol Configuration {
    var mapboxPublicKey: String { get }
}

public struct ProductionConfiguration: Configuration {
    public let mapboxPublicKey: String
    
    public init(mapboxPublicKey: String) {
        self.mapboxPublicKey = mapboxPublicKey
    }
}

public struct DevelopmentConfiguration: Configuration {
    public let mapboxPublicKey: String
    
    public init(mapboxPublicKey: String = ProcessInfo.processInfo.environment["MAPBOX_PUBLIC_KEY"] ?? "") {
        self.mapboxPublicKey = mapboxPublicKey
    }
} 

### File: SkiTrailsCore/Sources/SkiTrailsCore/Configuration/CoreConfig.swift
import Foundation

public enum Environment {
    case development
    case production
}

public class CoreConfig {
    public static let shared = CoreConfig()
    
    private var environment: Environment = .development
    private var configuration: Configuration?
    
    private init() {}
    
    public func configure(for environment: Environment, with configuration: Configuration? = nil) {
        self.environment = environment
        self.configuration = configuration
        
        if configuration == nil {
            switch environment {
            case .development:
                self.configuration = DevelopmentConfiguration()
            case .production:
                fatalError("Production configuration must be provided")
            }
        }
    }
    
    public var mapboxPublicKey: String {
        guard let configuration = configuration else {
            fatalError("CoreConfig must be configured before use")
        }
        return configuration.mapboxPublicKey
    }
    
    public var isDevelopment: Bool {
        return environment == .development
    }
    
    public var isProduction: Bool {
        return environment == .production
    }
} 

### File: SkiTrailsCore/Sources/SkiTrailsCore/Configuration/MapConfig.swift
import Foundation
import MapboxMaps

public struct MapConfig {
    public static let defaultCamera = CameraOptions(
        center: CLLocationCoordinate2D(latitude: 38.956414, longitude: -119.942227),
        zoom: 12,
        bearing: 0,
        pitch: 0
    )
} 

### File: SkiTrailsCore/Sources/SkiTrailsCore/Models/AppState.swift
import Foundation
import MapboxMaps

public class AppState: ObservableObject {
    @Published public var selectedResort: Resort?
    @Published public var selectedFeature: MapFeature?
    @Published public var routeStart: MapFeature?
    @Published public var routeEnd: MapFeature?
    @Published public var route: [CLLocationCoordinate2D]?
    
    public init(selectedResort: Resort? = nil,
         selectedFeature: MapFeature? = nil,
         routeStart: MapFeature? = nil,
         routeEnd: MapFeature? = nil,
         route: [CLLocationCoordinate2D]? = nil) {
        self.selectedResort = selectedResort
        self.selectedFeature = selectedFeature
        self.routeStart = routeStart
        self.routeEnd = routeEnd
        self.route = route
    }
    
    public func clearRoute() {
        routeStart = nil
        routeEnd = nil
        route = nil
    }
} 

### File: SkiTrailsCore/Sources/SkiTrailsCore/Models/HeavenlyData.swift
import Foundation
import MapboxMaps

public struct HeavenlyData {
    public static let resort = Resort(
        id: "heavenly",
        name: "Heavenly",
        location: CLLocationCoordinate2D(latitude: 38.956414, longitude: -119.942227),
        bounds: CoordinateBounds(
            southwest: CLLocationCoordinate2D(latitude: 38.925, longitude: -119.95),
            northeast: CLLocationCoordinate2D(latitude: 38.97, longitude: -119.90)
        ),
        lifts: [
            Resort.Lift(
                id: "gunbarrel",
                name: "Gunbarrel Express",
                type: .chairlift,
                status: .open,
                coordinates: [
                    CLLocationCoordinate2D(latitude: 38.939690, longitude: -119.944516),
                    CLLocationCoordinate2D(latitude: 38.947947, longitude: -119.943636)
                ]
            ),
            Resort.Lift(
                id: "canyon",
                name: "Canyon Express",
                type: .chairlift,
                status: .open,
                coordinates: [
                    CLLocationCoordinate2D(latitude: 38.925690, longitude: -119.916516),
                    CLLocationCoordinate2D(latitude: 38.933947, longitude: -119.913636)
                ]
            )
        ],
        runs: [
            Resort.Run(
                id: "gunbarrel_run",
                name: "Gunbarrel",
                difficulty: .expert,
                status: .open,
                coordinates: [
                    CLLocationCoordinate2D(latitude: 38.947947, longitude: -119.943636),
                    CLLocationCoordinate2D(latitude: 38.939690, longitude: -119.944516)
                ]
            ),
            Resort.Run(
                id: "orion",
                name: "Orion",
                difficulty: .intermediate,
                status: .open,
                coordinates: [
                    CLLocationCoordinate2D(latitude: 38.933947, longitude: -119.913636),
                    CLLocationCoordinate2D(latitude: 38.925690, longitude: -119.916516)
                ]
            )
        ],
        buildings: [
            Resort.Building(
                id: "california_lodge",
                name: "California Lodge",
                type: .lodge,
                coordinates: CLLocationCoordinate2D(latitude: 38.939690, longitude: -119.944516)
            ),
            Resort.Building(
                id: "tamarack_lodge",
                name: "Tamarack Lodge",
                type: .lodge,
                coordinates: CLLocationCoordinate2D(latitude: 38.925690, longitude: -119.916516)
            )
        ]
    )
} 

### File: SkiTrailsCore/Sources/SkiTrailsCore/Models/MapFeature.swift
import Foundation
import MapboxMaps

public enum MapFeature: Identifiable {
    case lift(Resort.Lift)
    case run(Resort.Run)
    case building(Resort.Building)
    
    public var id: String {
        switch self {
        case .lift(let lift):
            return lift.id
        case .run(let run):
            return run.id
        case .building(let building):
            return building.id
        }
    }
} 

### File: SkiTrailsCore/Sources/SkiTrailsCore/Models/Resort.swift
import Foundation
import MapboxMaps
import Turf

public struct Resort: Identifiable, Codable {
    public let id: String
    public let name: String
    public let location: CLLocationCoordinate2D
    public let bounds: CoordinateBounds
    public let lifts: [Lift]
    public let runs: [Run]
    public let buildings: [Building]
    
    public init(id: String, name: String, location: CLLocationCoordinate2D, bounds: CoordinateBounds, lifts: [Lift], runs: [Run], buildings: [Building]) {
        self.id = id
        self.name = name
        self.location = location
        self.bounds = bounds
        self.lifts = lifts
        self.runs = runs
        self.buildings = buildings
    }
    
    public struct Lift: Identifiable, Codable {
        public let id: String
        public let name: String
        public let type: LiftType
        public let status: Status
        public let coordinates: [CLLocationCoordinate2D]
        
        public init(id: String, name: String, type: LiftType, status: Status, coordinates: [CLLocationCoordinate2D]) {
            self.id = id
            self.name = name
            self.type = type
            self.status = status
            self.coordinates = coordinates
        }
        
        public enum LiftType: String, Codable {
            case chairlift
            case gondola
            case tbar
            case platter
            case rope
            case magic_carpet
        }
    }
    
    public struct Run: Identifiable, Codable {
        public let id: String
        public let name: String
        public let difficulty: Difficulty
        public let status: Status
        public let coordinates: [CLLocationCoordinate2D]
        
        public init(id: String, name: String, difficulty: Difficulty, status: Status, coordinates: [CLLocationCoordinate2D]) {
            self.id = id
            self.name = name
            self.difficulty = difficulty
            self.status = status
            self.coordinates = coordinates
        }
        
        public enum Difficulty: String, Codable {
            case beginner
            case intermediate
            case advanced
            case expert
        }
    }
    
    public struct Building: Identifiable, Codable {
        public let id: String
        public let name: String
        public let type: BuildingType
        public let coordinates: CLLocationCoordinate2D
        
        public init(id: String, name: String, type: BuildingType, coordinates: CLLocationCoordinate2D) {
            self.id = id
            self.name = name
            self.type = type
            self.coordinates = coordinates
        }
        
        public enum BuildingType: String, Codable {
            case lodge
            case restaurant
            case bathroom
            case parking
            case firstaid
            case rental
            case ticket
        }
    }
}

extension CLLocationCoordinate2D: Codable {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.unkeyedContainer()
        try container.encode(longitude)
        try container.encode(latitude)
    }
    
    public init(from decoder: Decoder) throws {
        var container = try decoder.unkeyedContainer()
        let longitude = try container.decode(Double.self)
        let latitude = try container.decode(Double.self)
        self.init(latitude: latitude, longitude: longitude)
    }
} 

### File: SkiTrailsCore/Sources/SkiTrailsCore/Models/Status.swift
import Foundation

public enum Status: String, Codable {
    case open
    case closed
    case hold
    case scheduled
    case unknown
    
    public var isOpen: Bool {
        return self == .open
    }
} 

### File: SkiTrailsCore/Sources/SkiTrailsCore/Routing/RoutingEngine.swift
import Foundation
import MapboxMaps
import Turf

public class RoutingEngine {
    private var nodes: [RouteNode] = []
    private var graph: [RouteNode: Set<RouteNode>] = [:]
    
    public init() {}
    
    public func buildGraph(from resort: Resort) {
        nodes = []
        graph = [:]
        
        // Add all lift coordinates as nodes
        for lift in resort.lifts where lift.status.isOpen {
            for coordinate in lift.coordinates {
                addNode(coordinate)
            }
            
            // Connect consecutive lift coordinates
            for i in 0..<lift.coordinates.count-1 {
                connect(lift.coordinates[i], to: lift.coordinates[i+1])
            }
        }
        
        // Add all run coordinates as nodes
        for run in resort.runs where run.status.isOpen {
            for coordinate in run.coordinates {
                addNode(coordinate)
            }
            
            // Connect consecutive run coordinates
            for i in 0..<run.coordinates.count-1 {
                connect(run.coordinates[i], to: run.coordinates[i+1])
            }
        }
    }
    
    private func addNode(_ coordinate: CLLocationCoordinate2D) {
        let node = RouteNode(coordinate: coordinate)
        if !nodes.contains(node) {
            nodes.append(node)
            graph[node] = Set<RouteNode>()
        }
    }
    
    private func connect(_ from: CLLocationCoordinate2D, to: CLLocationCoordinate2D) {
        let fromNode = nodes.first { $0.coordinate.latitude == from.latitude && $0.coordinate.longitude == from.longitude }!
        let toNode = nodes.first { $0.coordinate.latitude == to.latitude && $0.coordinate.longitude == to.longitude }!
        
        graph[fromNode]?.insert(toNode)
        graph[toNode]?.insert(fromNode)
    }
    
    public func findRoute(from start: MapFeature, to end: MapFeature) -> [CLLocationCoordinate2D]? {
        let startCoord: CLLocationCoordinate2D
        let endCoord: CLLocationCoordinate2D
        
        switch start {
        case .lift(let lift):
            startCoord = lift.coordinates.first!
        case .run(let run):
            startCoord = run.coordinates.first!
        case .building(let building):
            startCoord = building.coordinates
        }
        
        switch end {
        case .lift(let lift):
            endCoord = lift.coordinates.first!
        case .run(let run):
            endCoord = run.coordinates.first!
        case .building(let building):
            endCoord = building.coordinates
        }
        
        guard let startNode = findNearestNode(to: startCoord),
              let endNode = findNearestNode(to: endCoord) else {
            return nil
        }
        
        return findPath(from: startNode, to: endNode)
    }
    
    private func findNearestNode(to coordinate: CLLocationCoordinate2D) -> RouteNode? {
        return nodes.min { node1, node2 in
            let dist1 = calculateDistance(from: coordinate, to: node1.coordinate)
            let dist2 = calculateDistance(from: coordinate, to: node2.coordinate)
            return dist1 < dist2
        }
    }
    
    private func calculateDistance(from coord1: CLLocationCoordinate2D, to coord2: CLLocationCoordinate2D) -> Double {
        let location1 = CLLocation(latitude: coord1.latitude, longitude: coord1.longitude)
        let location2 = CLLocation(latitude: coord2.latitude, longitude: coord2.longitude)
        return location1.distance(from: location2)
    }
    
    private func findPath(from start: RouteNode, to end: RouteNode) -> [CLLocationCoordinate2D]? {
        var frontier = PriorityQueue<(RouteNode, Double)>(sort: { $0.1 < $1.1 })
        frontier.enqueue((start, 0))
        
        var cameFrom: [RouteNode: RouteNode] = [:]
        var costSoFar: [RouteNode: Double] = [start: 0]
        
        while let current = frontier.dequeue()?.0 {
            if current == end {
                break
            }
            
            guard let neighbors = graph[current] else { continue }
            
            for next in neighbors {
                let newCost = costSoFar[current]! + calculateDistance(from: current.coordinate, to: next.coordinate)
                
                if costSoFar[next] == nil || newCost < costSoFar[next]! {
                    costSoFar[next] = newCost
                    let priority = newCost + calculateDistance(from: next.coordinate, to: end.coordinate)
                    frontier.enqueue((next, priority))
                    cameFrom[next] = current
                }
            }
        }
        
        // Reconstruct path
        var current = end
        var path: [CLLocationCoordinate2D] = [current.coordinate]
        
        while current != start {
            guard let next = cameFrom[current] else { return nil }
            current = next
            path.append(current.coordinate)
        }
        
        return path.reversed()
    }
}

// Priority Queue implementation
private struct PriorityQueue<T> {
    private var elements: [(T, Double)] = []
    private let sort: (Double, Double) -> Bool
    
    init(sort: @escaping (Double, Double) -> Bool) {
        self.sort = sort
    }
    
    mutating func enqueue(_ element: (T, Double)) {
        elements.append(element)
        elements.sort { sort($0.1, $1.1) }
    }
    
    mutating func dequeue() -> (T, Double)? {
        return elements.isEmpty ? nil : elements.removeFirst()
    }
    
    var isEmpty: Bool {
        return elements.isEmpty
    }
} 

### File: SkiTrailsCore/Sources/SkiTrailsCore/Routing/RoutingTypes.swift
import Foundation
import MapboxMaps

public struct RouteNode: Hashable {
    public let coordinate: CLLocationCoordinate2D
    public let connections: Set<RouteNode>
    
    public init(coordinate: CLLocationCoordinate2D, connections: Set<RouteNode> = []) {
        self.coordinate = coordinate
        self.connections = connections
    }
    
    public func hash(into hasher: inout Hasher) {
        hasher.combine(coordinate.latitude)
        hasher.combine(coordinate.longitude)
    }
    
    public static func == (lhs: RouteNode, rhs: RouteNode) -> Bool {
        return lhs.coordinate.latitude == rhs.coordinate.latitude &&
               lhs.coordinate.longitude == rhs.coordinate.longitude
    }
} 

### File: SkiTrailsCore/Sources/SkiTrailsCore/Services/APIClient.swift
import Foundation

public enum APIError: Error {
    case invalidURL
    case networkError(Error)
    case invalidResponse
    case decodingError(Error)
}

public protocol APIClientProtocol {
    func fetch<T: Decodable>(_ type: T.Type, from endpoint: String) async throws -> T
}

public class APIClient: APIClientProtocol {
    private let baseURL: String
    private let session: URLSession
    
    public init(baseURL: String, session: URLSession = .shared) {
        self.baseURL = baseURL
        self.session = session
    }
    
    public func fetch<T: Decodable>(_ type: T.Type, from endpoint: String) async throws -> T {
        guard let url = URL(string: baseURL + endpoint) else {
            throw APIError.invalidURL
        }
        
        do {
            let (data, response) = try await session.data(from: url)
            
            guard let httpResponse = response as? HTTPURLResponse,
                  (200...299).contains(httpResponse.statusCode) else {
                throw APIError.invalidResponse
            }
            
            do {
                let decoder = JSONDecoder()
                return try decoder.decode(T.self, from: data)
            } catch {
                throw APIError.decodingError(error)
            }
        } catch {
            throw APIError.networkError(error)
        }
    }
} 

### File: .swiftpm/xcode/package.xcworkspace/contents.xcworkspacedata
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "self:">
   </FileRef>
</Workspace>


### File: .swiftpm/xcode/xcuserdata/bsteinher.xcuserdatad/xcschemes/xcschememanagement.plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>SchemeUserState</key>
	<dict>
		<key>SkiTrails-Package.xcscheme_^#shared#^_</key>
		<dict>
			<key>orderHint</key>
			<integer>0</integer>
		</dict>
		<key>SkiTrails.xcscheme_^#shared#^_</key>
		<dict>
			<key>orderHint</key>
			<integer>2</integer>
		</dict>
		<key>SkiTrailsCore.xcscheme_^#shared#^_</key>
		<dict>
			<key>orderHint</key>
			<integer>1</integer>
		</dict>
	</dict>
	<key>SuppressBuildableAutocreation</key>
	<dict>
		<key>SkiTrails</key>
		<dict>
			<key>primary</key>
			<true/>
		</dict>
		<key>SkiTrailsCore</key>
		<dict>
			<key>primary</key>
			<true/>
		</dict>
		<key>SkiTrailsCoreTests</key>
		<dict>
			<key>primary</key>
			<true/>
		</dict>
	</dict>
</dict>
</plist>
